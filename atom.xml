<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Cat&#39;s Blog</title>
  <subtitle>一饮一啄，莫非前定.</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://amao12580.github.io/"/>
  <updated>2016-06-01T10:57:11.027Z</updated>
  <id>http://amao12580.github.io/</id>
  
  <author>
    <name>Steven Cheng</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>消息系统的架构演进之路</title>
    <link href="http://amao12580.github.io/post/2016/06/Message-system-architecture-evolution/"/>
    <id>http://amao12580.github.io/post/2016/06/Message-system-architecture-evolution/</id>
    <published>2016-06-01T05:18:41.875Z</published>
    <updated>2016-06-01T10:57:11.027Z</updated>
    
    <content type="html">&lt;p&gt;暂时未完成&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/loading.gif&quot; alt=&quot;&quot; class=&quot;hx_lazyimg&quot; data-original=&quot;http://amao12580.github.io/img/03-消息系统改进1阶段的总体结构.jpg&quot;&gt;&lt;/p&gt;
</content>
    
    <summary type="html">
    
      消息系统在分阶段的架构演进
    
    </summary>
    
      <category term="Summary" scheme="http://amao12580.github.io/categories/Summary/"/>
    
    
      <category term="MessageSystem" scheme="http://amao12580.github.io/tags/MessageSystem/"/>
    
      <category term="architecture" scheme="http://amao12580.github.io/tags/architecture/"/>
    
  </entry>
  
  <entry>
    <title>当我们谈事务时，我们在谈什么</title>
    <link href="http://amao12580.github.io/post/2016/06/What-is-a-transaction/"/>
    <id>http://amao12580.github.io/post/2016/06/What-is-a-transaction/</id>
    <published>2016-06-01T05:01:50.068Z</published>
    <updated>2016-06-03T07:42:24.986Z</updated>
    
    <content type="html">&lt;p&gt;暂时未完成&lt;/p&gt;
&lt;h2 id=&quot;写在前面&quot;&gt;&lt;a href=&quot;#写在前面&quot; class=&quot;headerlink&quot; title=&quot;写在前面&quot;&gt;&lt;/a&gt;写在前面&lt;/h2&gt;&lt;p&gt;讨论传统关系型数据库内的事务，以及如何与NoSQL领域结合进行事务化。&lt;/p&gt;
&lt;h2 id=&quot;什么是事务？&quot;&gt;&lt;a href=&quot;#什么是事务？&quot; class=&quot;headerlink&quot; title=&quot;什么是事务？&quot;&gt;&lt;/a&gt;什么是事务？&lt;/h2&gt;&lt;p&gt;数据库事务（简称：事务）是数据库管理系统执行过程中的一个逻辑单位，由一个有限的数据库操作序列构成。这是使用Google Search以“事务”为关键字查找时，第一条是wikipedia给出的描述。&lt;/p&gt;
&lt;h2 id=&quot;单系统事务&quot;&gt;&lt;a href=&quot;#单系统事务&quot; class=&quot;headerlink&quot; title=&quot;单系统事务&quot;&gt;&lt;/a&gt;单系统事务&lt;/h2&gt;&lt;h3 id=&quot;ACID&quot;&gt;&lt;a href=&quot;#ACID&quot; class=&quot;headerlink&quot; title=&quot;ACID&quot;&gt;&lt;/a&gt;ACID&lt;/h3&gt;&lt;p&gt;redo log，undo log。&lt;/p&gt;
&lt;h3 id=&quot;逻辑事务-VS-物理事务&quot;&gt;&lt;a href=&quot;#逻辑事务-VS-物理事务&quot; class=&quot;headerlink&quot; title=&quot;逻辑事务 VS 物理事务&quot;&gt;&lt;/a&gt;逻辑事务 VS 物理事务&lt;/h3&gt;&lt;h3 id=&quot;编程式事务-VS-声明式事务&quot;&gt;&lt;a href=&quot;#编程式事务-VS-声明式事务&quot; class=&quot;headerlink&quot; title=&quot;编程式事务 VS 声明式事务&quot;&gt;&lt;/a&gt;编程式事务 VS 声明式事务&lt;/h3&gt;&lt;h3 id=&quot;事务隔离级别&quot;&gt;&lt;a href=&quot;#事务隔离级别&quot; class=&quot;headerlink&quot; title=&quot;事务隔离级别&quot;&gt;&lt;/a&gt;事务隔离级别&lt;/h3&gt;&lt;h4 id=&quot;默认隔离级别&quot;&gt;&lt;a href=&quot;#默认隔离级别&quot; class=&quot;headerlink&quot; title=&quot;默认隔离级别&quot;&gt;&lt;/a&gt;默认隔离级别&lt;/h4&gt;&lt;h5 id=&quot;不同ORM框架的默认隔离级别&quot;&gt;&lt;a href=&quot;#不同ORM框架的默认隔离级别&quot; class=&quot;headerlink&quot; title=&quot;不同ORM框架的默认隔离级别&quot;&gt;&lt;/a&gt;不同ORM框架的默认隔离级别&lt;/h5&gt;&lt;h5 id=&quot;不同DB-Proxy的默认隔离级别&quot;&gt;&lt;a href=&quot;#不同DB-Proxy的默认隔离级别&quot; class=&quot;headerlink&quot; title=&quot;不同DB Proxy的默认隔离级别&quot;&gt;&lt;/a&gt;不同DB Proxy的默认隔离级别&lt;/h5&gt;&lt;h5 id=&quot;不同RDBMS的默认隔离级别&quot;&gt;&lt;a href=&quot;#不同RDBMS的默认隔离级别&quot; class=&quot;headerlink&quot; title=&quot;不同RDBMS的默认隔离级别&quot;&gt;&lt;/a&gt;不同RDBMS的默认隔离级别&lt;/h5&gt;&lt;p&gt;不同存储引擎的默认隔离级别&lt;/p&gt;
&lt;h3 id=&quot;事务传播行为&quot;&gt;&lt;a href=&quot;#事务传播行为&quot; class=&quot;headerlink&quot; title=&quot;事务传播行为&quot;&gt;&lt;/a&gt;事务传播行为&lt;/h3&gt;&lt;h4 id=&quot;默认传播行为&quot;&gt;&lt;a href=&quot;#默认传播行为&quot; class=&quot;headerlink&quot; title=&quot;默认传播行为&quot;&gt;&lt;/a&gt;默认传播行为&lt;/h4&gt;&lt;h3 id=&quot;RDBMS如何权衡事务隔离与高并发读写？&quot;&gt;&lt;a href=&quot;#RDBMS如何权衡事务隔离与高并发读写？&quot; class=&quot;headerlink&quot; title=&quot;RDBMS如何权衡事务隔离与高并发读写？&quot;&gt;&lt;/a&gt;RDBMS如何权衡事务隔离与高并发读写？&lt;/h3&gt;&lt;h4 id=&quot;MVCC与Free-Lock&quot;&gt;&lt;a href=&quot;#MVCC与Free-Lock&quot; class=&quot;headerlink&quot; title=&quot;MVCC与Free Lock&quot;&gt;&lt;/a&gt;MVCC与Free Lock&lt;/h4&gt;&lt;p&gt;多线程环境下各种数据结构的实现有了很大的变化，每当我们更新某个数据的时候，我们都要考虑其它线程是否对其进行了修改。最简单的一种方法就是加锁，不过加锁会导致性能低下，而且可能阻塞其他线程。因此，我们引入了非阻塞(non-blocking)的算法 —— 通过CAS操作保证操作的原子性，同时我们还引入了 lock-free 的概念，它指的是一个线程出现问题（如阻塞，失败）但不影响其他线程（从总体看程序仍然是在运行的）&lt;/p&gt;
&lt;h5 id=&quot;共享锁&quot;&gt;&lt;a href=&quot;#共享锁&quot; class=&quot;headerlink&quot; title=&quot;共享锁&quot;&gt;&lt;/a&gt;共享锁&lt;/h5&gt;&lt;h5 id=&quot;排它锁&quot;&gt;&lt;a href=&quot;#排它锁&quot; class=&quot;headerlink&quot; title=&quot;排它锁&quot;&gt;&lt;/a&gt;排它锁&lt;/h5&gt;&lt;h5 id=&quot;间隙锁&quot;&gt;&lt;a href=&quot;#间隙锁&quot; class=&quot;headerlink&quot; title=&quot;间隙锁&quot;&gt;&lt;/a&gt;间隙锁&lt;/h5&gt;&lt;h3 id=&quot;在主从架构下RDBMS如何保证事务？&quot;&gt;&lt;a href=&quot;#在主从架构下RDBMS如何保证事务？&quot; class=&quot;headerlink&quot; title=&quot;在主从架构下RDBMS如何保证事务？&quot;&gt;&lt;/a&gt;在主从架构下RDBMS如何保证事务？&lt;/h3&gt;&lt;h3 id=&quot;在双主结构下RDBMS如何保证事务？&quot;&gt;&lt;a href=&quot;#在双主结构下RDBMS如何保证事务？&quot; class=&quot;headerlink&quot; title=&quot;在双主结构下RDBMS如何保证事务？&quot;&gt;&lt;/a&gt;在双主结构下RDBMS如何保证事务？&lt;/h3&gt;&lt;h3 id=&quot;双活数据中心的事务管理&quot;&gt;&lt;a href=&quot;#双活数据中心的事务管理&quot; class=&quot;headerlink&quot; title=&quot;双活数据中心的事务管理&quot;&gt;&lt;/a&gt;双活数据中心的事务管理&lt;/h3&gt;&lt;h2 id=&quot;分布式事务&quot;&gt;&lt;a href=&quot;#分布式事务&quot; class=&quot;headerlink&quot; title=&quot;分布式事务&quot;&gt;&lt;/a&gt;分布式事务&lt;/h2&gt;&lt;h3 id=&quot;事务解耦&quot;&gt;&lt;a href=&quot;#事务解耦&quot; class=&quot;headerlink&quot; title=&quot;事务解耦&quot;&gt;&lt;/a&gt;事务解耦&lt;/h3&gt;&lt;h3 id=&quot;事务补偿&quot;&gt;&lt;a href=&quot;#事务补偿&quot; class=&quot;headerlink&quot; title=&quot;事务补偿&quot;&gt;&lt;/a&gt;事务补偿&lt;/h3&gt;&lt;h3 id=&quot;事务回滚&quot;&gt;&lt;a href=&quot;#事务回滚&quot; class=&quot;headerlink&quot; title=&quot;事务回滚&quot;&gt;&lt;/a&gt;事务回滚&lt;/h3&gt;&lt;h3 id=&quot;最终资源一致性&quot;&gt;&lt;a href=&quot;#最终资源一致性&quot; class=&quot;headerlink&quot; title=&quot;最终资源一致性&quot;&gt;&lt;/a&gt;最终资源一致性&lt;/h3&gt;&lt;h3 id=&quot;与nosql&quot;&gt;&lt;a href=&quot;#与nosql&quot; class=&quot;headerlink&quot; title=&quot;与nosql&quot;&gt;&lt;/a&gt;与nosql&lt;/h3&gt;&lt;h3 id=&quot;阿里DTS&quot;&gt;&lt;a href=&quot;#阿里DTS&quot; class=&quot;headerlink&quot; title=&quot;阿里DTS&quot;&gt;&lt;/a&gt;阿里DTS&lt;/h3&gt;&lt;h2 id=&quot;Reference&quot;&gt;&lt;a href=&quot;#Reference&quot; class=&quot;headerlink&quot; title=&quot;Reference&quot;&gt;&lt;/a&gt;Reference&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://zh.wikipedia.org/wiki/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BA%8B%E5%8A%A1&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;数据库事务-维基百科&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</content>
    
    <summary type="html">
    
      数据库事务（简称：事务）是数据库管理系统执行过程中的一个逻辑单位，由一个有限的数据库操作序列构成。
    
    </summary>
    
      <category term="Summary" scheme="http://amao12580.github.io/categories/Summary/"/>
    
    
      <category term="Transaction" scheme="http://amao12580.github.io/tags/Transaction/"/>
    
      <category term="Spring" scheme="http://amao12580.github.io/tags/Spring/"/>
    
      <category term="MVCC" scheme="http://amao12580.github.io/tags/MVCC/"/>
    
      <category term="WAL" scheme="http://amao12580.github.io/tags/WAL/"/>
    
      <category term="RedoLog" scheme="http://amao12580.github.io/tags/RedoLog/"/>
    
      <category term="RelayLog" scheme="http://amao12580.github.io/tags/RelayLog/"/>
    
  </entry>
  
  <entry>
    <title>分布式软件理论总结</title>
    <link href="http://amao12580.github.io/post/2016/05/Summary-of-distributed-theory/"/>
    <id>http://amao12580.github.io/post/2016/05/Summary-of-distributed-theory/</id>
    <published>2016-05-23T03:34:28.000Z</published>
    <updated>2016-06-03T02:31:04.879Z</updated>
    
    <content type="html">&lt;p&gt;&lt;img src=&quot;/images/loading.gif&quot; alt=&quot;&quot; class=&quot;hx_lazyimg&quot; data-original=&quot;http://amao12580.github.io/img/thinking.jpg&quot;&gt;&lt;/p&gt;
&lt;h1 id=&quot;软件系统的本质&quot;&gt;&lt;a href=&quot;#软件系统的本质&quot; class=&quot;headerlink&quot; title=&quot;软件系统的本质&quot;&gt;&lt;/a&gt;软件系统的本质&lt;/h1&gt;&lt;p&gt;软件是现实的抽象，讨论抽象的本质是困难的，让我们一起在现实中思考。小到一支笔，大到一部汽车，这些产品的出现，使我们在现实生活中得到了方便。这里说的方便，是指因为使用了这些产品，降低了成本，提高了效率。在没有笔的时代，想要记录信息需要结绳、岩画或篆刻，这是高成本的，效率也很低。同样的，没有汽车的时代，想要到达另一个城市，会因为恶劣天气而被迫中途搁置，相应的通行时间也会比现在长得多。进一步的思考，笔与汽车的共同点又在哪里呢？&lt;/p&gt;
&lt;p&gt;笔与汽车，这些产品是为了满足人们的各类生活需求而发明的。即，人们因为现实需要，而发明或改进了产品，产品是为了帮助人们更好的生活而存在。同样的，软件系统也是如此，人们出于远距离沟通交流需要，发明电话拨号系统；因为更随时随地的信息多样化交流，发明了各种互联网IM产品。&lt;/p&gt;
&lt;p&gt;软件系统是依托于人们现实需求而存在，用以辅助人们更好的生活，它是现实世界在虚拟世界的抽象。同样的软件系统也存在着兴衰淘汰，一款软件刚问世时，受欢迎程度总是处于低谷，存在现实世界对其接受适应的时间窗。突破时间窗，进而逐渐闻名天下，此时依托此软件又会催生出许多子软件链（如chromium的众多壳浏览器、SVN的众多客户端）。随着技术革新，软件产业也会更新换代，跟不上时代的软件系统会逐渐退出市场（如vista操作系统的短命）。但市场总是存在需要的，类似的软件在倒下后总会有后继者，如浏览器，这几乎在国内，每家互联网公司都想做或者已经在做。&lt;/p&gt;
&lt;h1 id=&quot;不良设计的局限性&quot;&gt;&lt;a href=&quot;#不良设计的局限性&quot; class=&quot;headerlink&quot; title=&quot;不良设计的局限性&quot;&gt;&lt;/a&gt;不良设计的局限性&lt;/h1&gt;&lt;p&gt;在软件系统的发展初期，适用面狭窄，功能单一、用户少、价值不够高，造成对软件系统研发的不重视，成本投入低。相应的，软件所带来的经济收益也是有限的。此时的软件系统往往谈不上架构，往往是一个软件系统承载了所有功能，单个功能模块没有边界，逻辑分散，而各个功能模块之间的耦合关系是散乱的。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/loading.gif&quot; alt=&quot;&quot; class=&quot;hx_lazyimg&quot; data-original=&quot;http://amao12580.github.io/img/chaos.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;在软件系统有机会成长起来后，带来了一定的经济收益。我们会思考软件系统的功能增多，更适应于用户（市场需要），或者考虑增强原有用户黏性，此时会对软件系统提出更多要求。而初期功能模块散乱的堆叠，对迫切需要的可扩展性带来了的麻烦，紧耦合的架构造成牵一发而动全身的问题，新功能的增加，往往意味着巨大地改造成本。勉强加上一些功能后，整个软件系统简直是乱作一团，就像是一堆红豆绿豆，这样的软件系统，我们称之为集中式软件系统。&lt;/p&gt;
&lt;p&gt;集中式的软件系统还对重构带来挑战，随着功能需求越来越频繁的提出，往往意味着需要更短的版本迭代周期。现有系统无法灵活扩展，意味着需要对整个软件系统进行重构，而等到软件散乱性膨胀到一定程度，重构几乎变成不可完成的任务，就算是系统初始负责人，也无法评估重构带来的风险与收益究竟谁更多？&lt;/p&gt;
&lt;h2 id=&quot;停不下来的运动员&quot;&gt;&lt;a href=&quot;#停不下来的运动员&quot; class=&quot;headerlink&quot; title=&quot;停不下来的运动员&quot;&gt;&lt;/a&gt;停不下来的运动员&lt;/h2&gt;&lt;p&gt;集中式的软件系统在濒危阶段，开发团队往往面临两难，团队任何人都知道急需重构，但因为没有决策权，最高决策领导也顾虑着市场利益，而不可能给出重构所需的资源(时间、人力、软硬件)。在愈发杂乱的系统上进行维护和新功能叠加，这让团队内的每个人都需要指数级的投入成本，往往还达不到市场需要的质量。&lt;/p&gt;
&lt;p&gt;就像田径400米接力比赛中，只能跑第一棒的运动员，本应在交棒后停下来休息，自我调整。而由于接手下一棒的运动员迟迟不能到位，运动员只能咬牙坚持跑第二棒，但迈出的每一步都越来越累，没法再像刚开始保持加速度。更令人担忧的是，此时裁判还吹响了冲刺哨，要求运动员进行冲锋。这样，运动员只有倒下了。相应的，软件系统到此时，开发团队成员会加速流失，新招进来的人也很难理解整套系统的协作，经常顾此失彼，从而导致最终的系统失败。&lt;/p&gt;
&lt;p&gt;这也就是为什么CTO必需对技术团队保持深入理解，同时还应有对产品、开发的最高决策权，以支持技术团队在适时进行系统级别的重构，让失去体力的软件系统下线休息，换上更适合的新软件系统上线，从而更好地满足公司的战略需求，这是非常有必要的。&lt;/p&gt;
&lt;h1 id=&quot;向敏捷开发过渡&quot;&gt;&lt;a href=&quot;#向敏捷开发过渡&quot; class=&quot;headerlink&quot; title=&quot;向敏捷开发过渡&quot;&gt;&lt;/a&gt;向敏捷开发过渡&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;/images/loading.gif&quot; alt=&quot;&quot; class=&quot;hx_lazyimg&quot; data-original=&quot;http://amao12580.github.io/img/building-blocks.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;在软件系统有机会从集中式软件模式，过渡到积木型的软件模式后。系统原有是100%的功能堆叠到一个系统，现在变成了多个积木，也就是软件子系统，每个积木只负责其中的部分功能，积木间的协作，从而拼装出完整的软件系统。&lt;/p&gt;
&lt;h2 id=&quot;快速交付&quot;&gt;&lt;a href=&quot;#快速交付&quot; class=&quot;headerlink&quot; title=&quot;快速交付&quot;&gt;&lt;/a&gt;快速交付&lt;/h2&gt;&lt;p&gt;集中式的软件往往灵活性低下，这体现在很多方面。&lt;/p&gt;
&lt;p&gt;1.设计的灵活性，想要以好的设计替换掉不再适应设计方案，会遭遇无法评估改造成本。&lt;/p&gt;
&lt;p&gt;2.构建的灵活性，软件功能过于集中，导致一个小的编译问题，都会影响整个软件的构建，就像走钢丝一样，必需每一步都完美无缺才能安全走到终点。&lt;/p&gt;
&lt;p&gt;3.测试的灵活性，测试任务因为功能互相紧耦合而变得繁重，无法评估已经做好的功能是否会受到影响。&lt;/p&gt;
&lt;p&gt;4.部署的灵活性，运维无法根据系统的流量特性来优化软硬件配置，如JVM调优，Load Balance等。&lt;/p&gt;
&lt;p&gt;5.修复的灵活性，这一点往往在集中式软件中是一个优势，在线上出现问题，只需要简单的分析少量的运行日志即可定位问题，这在积木性系统中是一个软肋。&lt;/p&gt;
&lt;p&gt;敏捷开发的主要优势就在于，合理的利用分治思想，将复杂的功能的系统模块化处理，拆分成由只有简单功能的子系统而拼凑出来的完整系统，每一个子系统可以交付到小团队来维护，甚至与有单独的运维人员来进行保障。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/loading.gif&quot; alt=&quot;&quot; class=&quot;hx_lazyimg&quot; data-original=&quot;http://amao12580.github.io/img/MircoService.png&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;可维护性&quot;&gt;&lt;a href=&quot;#可维护性&quot; class=&quot;headerlink&quot; title=&quot;可维护性&quot;&gt;&lt;/a&gt;可维护性&lt;/h2&gt;&lt;p&gt;这是一个巨大的转变，首当其冲的就是可维护性，只需要定义一套灵活的通信协议，子系统之间通过这套协议进行通讯，我们在对子系统内部的功能进行维护时，不必担忧其他子系统受到干扰。这也存在一个前提，能够封装在一个子系统的功能模块集合，必须是内聚型的，它们几乎很少对外层子系统产生耦合，或者通过统一的出口进行耦合关联。&lt;/p&gt;
&lt;h2 id=&quot;可扩展性&quot;&gt;&lt;a href=&quot;#可扩展性&quot; class=&quot;headerlink&quot; title=&quot;可扩展性&quot;&gt;&lt;/a&gt;可扩展性&lt;/h2&gt;&lt;p&gt;其次是软件的可扩展性，新功能的开发，只需要新加一个子系统，扩展通讯协议，就可以满足要求，这对团队内的任何一个人都是令人振奋的。&lt;/p&gt;
&lt;h2 id=&quot;隔离性&quot;&gt;&lt;a href=&quot;#隔离性&quot; class=&quot;headerlink&quot; title=&quot;隔离性&quot;&gt;&lt;/a&gt;隔离性&lt;/h2&gt;&lt;p&gt;积木型的软件构建，还给了我们保持专注的可能。现在我们可以为软件进行动静分离设计，以适应不同的最佳部署方式。可以按照系统流量特性，应用CQRS架构，提供更好的局部性能。进一步的还可以为强共用性的功能进行独立剥离出来，譬如单独的文件系统负责所有的文件服务，以在避免各个积木内部的重复造轮子，独立的服务还为以后的：可维护性、伸缩性带来了诸多方便。&lt;/p&gt;
&lt;h2 id=&quot;质量可控&quot;&gt;&lt;a href=&quot;#质量可控&quot; class=&quot;headerlink&quot; title=&quot;质量可控&quot;&gt;&lt;/a&gt;质量可控&lt;/h2&gt;&lt;p&gt;同时，软件的质量可以得到保证，测试部门可以明确的针对某个软件子系统进行测试，而不需要每次系统上线都进行整体测试，工作量的降低，在相等的时间内，有了更多的时间进行问题修复，这往往意味着质量的提高。&lt;/p&gt;
&lt;p&gt;积木型的软件，是对积木之间通讯协议的高要求，实际上，我们需要引入一整套消息通讯中间件来解决这个问题，在SOA和EDA架构中，最为关键的就是MQ协议的设计了。&lt;/p&gt;
&lt;p&gt;松耦合的模式还带来局部失败和最终一致性的问题，可能会给用户造成短时间迷惑，但不影响最终的数据状态统一，这在传统软件领域往往是不可接受的，但进入到互联网后，在系统层面往往需要进行权衡，是市场机遇重要？还是少部分的用户利益重要？这个问题需要每一个互联网人的思考，产品是不是要满足每一个人的要求呢？&lt;/p&gt;
&lt;h1 id=&quot;分布式系统的利与弊&quot;&gt;&lt;a href=&quot;#分布式系统的利与弊&quot; class=&quot;headerlink&quot; title=&quot;分布式系统的利与弊&quot;&gt;&lt;/a&gt;分布式系统的利与弊&lt;/h1&gt;&lt;h2 id=&quot;软件的构成&quot;&gt;&lt;a href=&quot;#软件的构成&quot; class=&quot;headerlink&quot; title=&quot;软件的构成&quot;&gt;&lt;/a&gt;软件的构成&lt;/h2&gt;&lt;p&gt;概括的讲，软件普遍是由三部分组成：接入、逻辑、存储。其中接入是可能没有的，比如定时任务型软件，由操作系统时间来触发，不需要外界的主动调度。而逻辑和存储，很难有软件是不需要的。而比如典型的在线社交服务，常规的构成可以分为：聊天服务、长连接服务、推送服务、好友信息服务、文件服务、推荐服务、广告服务。这些按业务功能相关性而划分的服务，没有哪一个可以脱离接入、逻辑和存储的。这些服务从本质上来说大部分都是OLTP(&lt;a href=&quot;http://blog.csdn.net/tianlesoftware/article/details/5794844&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Online Transaction Processing&lt;/a&gt;)，就是将现实生活中的沟通交流需求转移到了互联网进行。&lt;/p&gt;
&lt;h2 id=&quot;SOA-VS-EDA&quot;&gt;&lt;a href=&quot;#SOA-VS-EDA&quot; class=&quot;headerlink&quot; title=&quot;SOA VS EDA&quot;&gt;&lt;/a&gt;SOA VS EDA&lt;/h2&gt;&lt;h3 id=&quot;什么是SOA？&quot;&gt;&lt;a href=&quot;#什么是SOA？&quot; class=&quot;headerlink&quot; title=&quot;什么是SOA？&quot;&gt;&lt;/a&gt;什么是SOA？&lt;/h3&gt;&lt;h4 id=&quot;SOA-VS-Mirco-Service&quot;&gt;&lt;a href=&quot;#SOA-VS-Mirco-Service&quot; class=&quot;headerlink&quot; title=&quot;SOA VS Mirco Service&quot;&gt;&lt;/a&gt;SOA VS Mirco Service&lt;/h4&gt;&lt;h3 id=&quot;什么是EDA？&quot;&gt;&lt;a href=&quot;#什么是EDA？&quot; class=&quot;headerlink&quot; title=&quot;什么是EDA？&quot;&gt;&lt;/a&gt;什么是EDA？&lt;/h3&gt;&lt;h3 id=&quot;分场景使用&quot;&gt;&lt;a href=&quot;#分场景使用&quot; class=&quot;headerlink&quot; title=&quot;分场景使用&quot;&gt;&lt;/a&gt;分场景使用&lt;/h3&gt;&lt;h2 id=&quot;Design-for-failure&quot;&gt;&lt;a href=&quot;#Design-for-failure&quot; class=&quot;headerlink&quot; title=&quot;Design for failure&quot;&gt;&lt;/a&gt;Design for failure&lt;/h2&gt;&lt;h3 id=&quot;Fast-fail-VS-Retry&quot;&gt;&lt;a href=&quot;#Fast-fail-VS-Retry&quot; class=&quot;headerlink&quot; title=&quot;Fast fail VS Retry&quot;&gt;&lt;/a&gt;Fast fail VS Retry&lt;/h3&gt;&lt;h2 id=&quot;无状态&quot;&gt;&lt;a href=&quot;#无状态&quot; class=&quot;headerlink&quot; title=&quot;无状态&quot;&gt;&lt;/a&gt;无状态&lt;/h2&gt;&lt;h2 id=&quot;应用中心和任务中心&quot;&gt;&lt;a href=&quot;#应用中心和任务中心&quot; class=&quot;headerlink&quot; title=&quot;应用中心和任务中心&quot;&gt;&lt;/a&gt;应用中心和任务中心&lt;/h2&gt;&lt;p&gt;单点服务向多点服务的转变&lt;/p&gt;
&lt;p&gt;原因：&lt;br&gt;性能要求，多节点同时参与服务(按流量权重分发，负载均衡；按读写流量分发，读写分离)。&lt;br&gt;允许少部分节点失败，更可靠的运行。&lt;/p&gt;
&lt;p&gt;数据存储跨机分片，同时每片在多机存在复制集。计算资源无状态，本身就可以动态管理。便捷的扩容缩容(伸缩性)。&lt;/p&gt;
&lt;p&gt;因业务分拆，降低耦合粒度，降低系统扩展成本(可扩展性)，更高的可维护性。&lt;/p&gt;
&lt;p&gt;带来的问题。&lt;br&gt;系统内部改造，支持多节点转变。&lt;/p&gt;
&lt;p&gt;分布式事务，事务补偿。&lt;/p&gt;
&lt;p&gt;分布式存储&lt;/p&gt;
&lt;p&gt;分布式访问&lt;/p&gt;
&lt;p&gt;容忍最终一致性。&lt;/p&gt;
&lt;h1 id=&quot;Reference&quot;&gt;&lt;a href=&quot;#Reference&quot; class=&quot;headerlink&quot; title=&quot;Reference&quot;&gt;&lt;/a&gt;Reference&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&quot;https://blog.eood.cn/exception&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;互联网系统可靠性基础：正确的异常处理&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&quot;http://www.sczyh30.com/posts/Microservice/circuit-breaker-pattern/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;微服务设计：熔断器模式&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&quot;http://ju.outofmemory.cn/entry/195996&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;采用断路器设计模式来保护软件&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
</content>
    
    <summary type="html">
    
      集中式的软件系统在濒危阶段，开发团队往往面临两难，团队任何人都知道急需重构，但因为没有决策权，最高决策领导也顾虑着市场利益，而不可能给出重构所需的资源(时间、人力、软硬件)。在愈发杂乱的系统上进行维护和新功能叠加，这让团队内的每个人都需要指数级的投入成本，往往还达不到市场需要的质量。
    
    </summary>
    
      <category term="Summary" scheme="http://amao12580.github.io/categories/Summary/"/>
    
    
      <category term="Distributed" scheme="http://amao12580.github.io/tags/Distributed/"/>
    
  </entry>
  
  <entry>
    <title>软件重构经验总结</title>
    <link href="http://amao12580.github.io/post/2016/05/Software-refactoring-experience-summary/"/>
    <id>http://amao12580.github.io/post/2016/05/Software-refactoring-experience-summary/</id>
    <published>2016-05-17T07:24:39.000Z</published>
    <updated>2016-06-01T09:18:38.301Z</updated>
    
    <content type="html">&lt;h1 id=&quot;先了解&quot;&gt;&lt;a href=&quot;#先了解&quot; class=&quot;headerlink&quot; title=&quot;先了解&quot;&gt;&lt;/a&gt;先了解&lt;/h1&gt;&lt;h2 id=&quot;了解中发现问题症结&quot;&gt;&lt;a href=&quot;#了解中发现问题症结&quot; class=&quot;headerlink&quot; title=&quot;了解中发现问题症结&quot;&gt;&lt;/a&gt;了解中发现问题症结&lt;/h2&gt;&lt;h2 id=&quot;了解中思考解决方案&quot;&gt;&lt;a href=&quot;#了解中思考解决方案&quot; class=&quot;headerlink&quot; title=&quot;了解中思考解决方案&quot;&gt;&lt;/a&gt;了解中思考解决方案&lt;/h2&gt;&lt;h2 id=&quot;选取合适的解决方案&quot;&gt;&lt;a href=&quot;#选取合适的解决方案&quot; class=&quot;headerlink&quot; title=&quot;选取合适的解决方案&quot;&gt;&lt;/a&gt;选取合适的解决方案&lt;/h2&gt;&lt;h2 id=&quot;保留可扩展性&quot;&gt;&lt;a href=&quot;#保留可扩展性&quot; class=&quot;headerlink&quot; title=&quot;保留可扩展性&quot;&gt;&lt;/a&gt;保留可扩展性&lt;/h2&gt;&lt;h2 id=&quot;保留可维护性&quot;&gt;&lt;a href=&quot;#保留可维护性&quot; class=&quot;headerlink&quot; title=&quot;保留可维护性&quot;&gt;&lt;/a&gt;保留可维护性&lt;/h2&gt;&lt;h1 id=&quot;再动手&quot;&gt;&lt;a href=&quot;#再动手&quot; class=&quot;headerlink&quot; title=&quot;再动手&quot;&gt;&lt;/a&gt;再动手&lt;/h1&gt;&lt;h2 id=&quot;重构方案的评审&quot;&gt;&lt;a href=&quot;#重构方案的评审&quot; class=&quot;headerlink&quot; title=&quot;重构方案的评审&quot;&gt;&lt;/a&gt;重构方案的评审&lt;/h2&gt;&lt;h2 id=&quot;理清方案的优势与不足&quot;&gt;&lt;a href=&quot;#理清方案的优势与不足&quot; class=&quot;headerlink&quot; title=&quot;理清方案的优势与不足&quot;&gt;&lt;/a&gt;理清方案的优势与不足&lt;/h2&gt;&lt;h2 id=&quot;资源预先到位&quot;&gt;&lt;a href=&quot;#资源预先到位&quot; class=&quot;headerlink&quot; title=&quot;资源预先到位&quot;&gt;&lt;/a&gt;资源预先到位&lt;/h2&gt;&lt;p&gt;包括重构的时间争取，参与人员配比，对其他软硬件资源、中间件的预研。&lt;/p&gt;
&lt;h2 id=&quot;重构前后的效果量化&quot;&gt;&lt;a href=&quot;#重构前后的效果量化&quot; class=&quot;headerlink&quot; title=&quot;重构前后的效果量化&quot;&gt;&lt;/a&gt;重构前后的效果量化&lt;/h2&gt;&lt;h2 id=&quot;充分的测试&quot;&gt;&lt;a href=&quot;#充分的测试&quot; class=&quot;headerlink&quot; title=&quot;充分的测试&quot;&gt;&lt;/a&gt;充分的测试&lt;/h2&gt;&lt;p&gt;基础方面的重构，需要充分的测试&lt;/p&gt;
&lt;h1 id=&quot;方案上线&quot;&gt;&lt;a href=&quot;#方案上线&quot; class=&quot;headerlink&quot; title=&quot;方案上线&quot;&gt;&lt;/a&gt;方案上线&lt;/h1&gt;</content>
    
    <summary type="html">
    
      重构更多的是对软件的可维护性和可扩展性进行提高，无法完成重构的软件，往往都逃不过被淘汰的命运。何时适宜进行重构，需要考量的因素有三个：成本、收益、风险。其中风险是最为重要的，如果系统不进行重构，在未来可能带来巨大的问题，如不能适应分布式部署。此时就有必要进行重构了，重构的同时还需要考虑完成重构需要的成本，包括时间成本、人力成本，团队往往时刻肩负着新功能的开发和旧功能的维护工作，如何在不多的时间和人力中挤出资源呢？
    
    </summary>
    
      <category term="Summary" scheme="http://amao12580.github.io/categories/Summary/"/>
    
    
      <category term="Experience" scheme="http://amao12580.github.io/tags/Experience/"/>
    
      <category term="Refactor" scheme="http://amao12580.github.io/tags/Refactor/"/>
    
  </entry>
  
  <entry>
    <title>如何更好地管理技术团队？</title>
    <link href="http://amao12580.github.io/post/2016/05/How-to-better-manage-the-technical-team/"/>
    <id>http://amao12580.github.io/post/2016/05/How-to-better-manage-the-technical-team/</id>
    <published>2016-05-11T10:38:31.000Z</published>
    <updated>2016-06-06T10:52:46.981Z</updated>
    
    <content type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;h2 id=&quot;PM与TL的区别&quot;&gt;&lt;a href=&quot;#PM与TL的区别&quot; class=&quot;headerlink&quot; title=&quot;PM与TL的区别&quot;&gt;&lt;/a&gt;PM与TL的区别&lt;/h2&gt;&lt;p&gt;其实一个Team Leader的职责与Project Manager相像，但Team Leader更着重于技术开发方面，通常一个大型项目都会有一两个开发团队由Team Leader带领，负责开发核心部分，而其它部分分派给不同开发小组或者分派给外包公司。在网上常看到几句话，贴切地形容了PM与TL的区别：“技术人员乐于被领导；但他们不喜欢被管理，不喜欢像牛一样被驱赶或指挥。管理者强迫人们服从他们的命令，而领导者则会带领他们一起工作。管理是客观的，没有个人感情因素，它假定被管理者没有思想和感受，被告知要做什么和该如何做。领导是引领、引导，它激励人们达成目标。领导力是带有强烈个人感情色彩的，它不是你能命令的，也不是你能测量评估和测试的。”&lt;/p&gt;
&lt;p&gt;TL对于团队内的member，必须在技术上能够进行胜任领导，他就像黑夜里的灯塔，引导和修正member前进的航向。因此TL也必需保持照亮团队，保持对member的充分了解，并在技术领域投入持续的学习热情，向团队成员传道，补齐短板，让大家的核心战斗力一起提高。&lt;/p&gt;
&lt;p&gt;无论是PM与TL，对业务与技术都要有深入的了解，只是PM更侧重于业务的管理，盈利的多少，风险的大小等等，而TL则侧重于项目的成本，开发的难度，软件的架构等技术方面的问题。在某些人眼中，技术与管理就像鱼与熊掌，不可兼得，但依在下看来，两者却是秤不离砣，密不可分。只要及时提升自己对技术与管理的认识，不断地向深一层发展，要从程序员提升到技术管理人员只是时间的问题。&lt;/p&gt;
&lt;p&gt;团队规模有限时，分工很可能没这么清晰，很多时候TL和PM是同一个人在兼任，角色的模糊，可能带来职责和权利的混乱，而且个人精力也有限，仅适合任务量较小时实行。&lt;/p&gt;
&lt;h2 id=&quot;技术管理与团队管理的区别&quot;&gt;&lt;a href=&quot;#技术管理与团队管理的区别&quot; class=&quot;headerlink&quot; title=&quot;技术管理与团队管理的区别&quot;&gt;&lt;/a&gt;技术管理与团队管理的区别&lt;/h2&gt;&lt;p&gt;技术团队与其它的团队的区别，可能在于技术人员的管理难度。一方面因为领域之间的差异性，譬如前端技术链与后端技术链的深与广，导致熟悉前端的同时，很难对后端保持足够的了解。另一方面在领域内的差异性，典型的是多年争论C语言与Java语言的优劣，忽视了技术都有局限性，脱离了使用需求的比较没有意义。如果技术人员比较狭隘，往往无法理解对方的差异性，从而造成不必要的争议。这一点在年轻的团队中，是很突出的问题，大家普遍经验欠缺，对上下游的技术无法做到足够认知，同时因为年轻而无法接受建议，行成内耗。&lt;/p&gt;
&lt;p&gt;技术团队管理需要划分为正切的两个方向：技术管理和团队管理。管理的目标是：提高协作时的执行力，执行效率，并约束进行规范执行。技术管理的目标是：保持并引导团队成员之间的技术协作一致性，如前端技术团队和后端技术团队。由技术负责人制定日常规范，推动规范的落地，以公有的强制约定来避免不必要的内耗。规范的含义是比较广泛的：设计规范、编码规范、安全规范、接口规范、部署规范。团队管理解决的问题是：如何持久降低团队之间或团队成员之间的合作成本？如产品团队和技术团队。除了leader的影响，往往需要合理的行政制度来作为基础。好的行政制度往往是一家公司最为重要的部分，它就像生态系统中的土壤一样重要，有了好的土壤，才可能生长出好的团队，而一个好的产品是往往需要团队来持续打磨的。&lt;/p&gt;
&lt;p&gt;从纯粹的技术工作者转向管理者难点在于是否具备了管理能力？对与团队内的成员，是否一致的认为在你的带领下可以得到更好的发展？可以是经济利益上的或职业发展上的。对于上层决策领导是否认为你可担此大任？而领导经常不相信你已经具备管理能力，或确实缺少部分能力(可能是软实力，语言沟通能力)，这在国外很常见，管理层大多是美国人或印度人，中国人由于文化上的本位差异，很难上升到管理层。&lt;/p&gt;
&lt;h1 id=&quot;技术管理&quot;&gt;&lt;a href=&quot;#技术管理&quot; class=&quot;headerlink&quot; title=&quot;技术管理&quot;&gt;&lt;/a&gt;技术管理&lt;/h1&gt;&lt;h2 id=&quot;原则&quot;&gt;&lt;a href=&quot;#原则&quot; class=&quot;headerlink&quot; title=&quot;原则&quot;&gt;&lt;/a&gt;原则&lt;/h2&gt;&lt;p&gt;KISS原则是英语Keep It Simple, Stupid 的首字母缩略字。KISS原则是指在设计当中应當注重简约的原则。&lt;/p&gt;
&lt;h3 id=&quot;命名规范&quot;&gt;&lt;a href=&quot;#命名规范&quot; class=&quot;headerlink&quot; title=&quot;命名规范&quot;&gt;&lt;/a&gt;命名规范&lt;/h3&gt;&lt;p&gt;我们在编写任何程序之前，第一件事要做的就是命名。&lt;/p&gt;
&lt;p&gt;形如：需求文档名称，概要设计文档名称，接口文档名称，软件系统名称，功能模块名称，类名称，方法名称，参数名称…&lt;/p&gt;
&lt;p&gt;在认识陌生人时，第一次接触往往互递名片。熟络后的沟通交流，都以名字来开始了。一个人的名字是否好记，影响会有多大？我以前公司同事丁某某，父母取名用了生僻字，导致每次登机之前需要到机场值班经理盖章，浪费很多时间。而恰巧他是一位销售人员，每周都有2~3次的飞行，你在想他为什么不去换名字？想想30多岁的人生积累，你需要多少成本改名字吧？想象不出来，问问自己换一个使用5年的手机号码成本是多大吧？&lt;/p&gt;
&lt;h4 id=&quot;重要性&quot;&gt;&lt;a href=&quot;#重要性&quot; class=&quot;headerlink&quot; title=&quot;重要性&quot;&gt;&lt;/a&gt;重要性&lt;/h4&gt;&lt;p&gt;命名规范竟如此重要，但大多数开发者的命名习惯往往没有你想象的那么好。除了上面提到的生僻字问题，还有很多人喜欢用拼音去命名类、函数，甚至是变量。我不知道这是英文词汇量的问题还是个人风格，但我个人非常不提倡这样做。如何优雅地为程序中的变量和函数命名？很简单，把你的变量名拎出来，问别人，你看到这个名字会想到什么，他说的和你想的一致，就用，否则就改。改到基本上不懂程序的人都能大概看懂你写的是什么，就优雅了。&lt;/p&gt;
&lt;p&gt;为什么重要？提高可维护性。不加约束的开发者写出来的代码，就像是大家临时拼凑出来的一桌菜，你上粤菜，他上川菜。虽然都好吃，但没有人全想吃，造成的局面是，爱吃粤菜的人总是夹粤菜，爱吃川菜的就不去吃粤菜了。在代码上来讲，各自的代码风格迥异，导致理解成本加大，你负责的代码需要修改时，就只有你能改了，团队其他人很难帮得上忙，如果修改工作量比较大，这岂不是把自己逼死吗？如果结合好的代码注释和设计文档，会不会理解成本下降呢？但就算是文档写得再详细，我们也要去读代码，所以文档主要是体现思路和反映需求和设计。在程序上，我们的命令应当和文档中的术语保持一致，而程序中的命名也应该是用和文档相同的风格，这样，我们可以少很多理解上的成本。好的代码在命名上是完全可读的，代码即文档，做到这点，可以极大的提高团队内协作效率。&lt;/p&gt;
&lt;p&gt;比较常见的有下面三种命名方式：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;驼峰(Camel)命名法:又称小驼峰命名法，除首单词外，其余所有单词的第一个字母大写。GetOrderList&lt;/li&gt;
&lt;li&gt;帕斯卡(Pascal)命名法:又称大驼峰命名法，所有单词的第一个字母大写。gtOrderList&lt;/li&gt;
&lt;li&gt;蛇形(Snake)命名法:单词与单词间用下划线做间隔。get_order_list&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;一般在命名函数和变量时，多使用小驼峰；命名类名多使用大驼峰，不建议使用蛇形命名。如在命名数据库表名时，最好使用小驼峰以一致性的对应到pojo。&lt;/p&gt;
&lt;p&gt;好的命名，还给代码审计、代码排错工作降低成本，在做code review时，如果缺失详细注释，规范化的命名使大家的理解成本降低，从而让审计工作更容易的完成。我们回过头来想，很多公司无法推动代码审计的实行，到底是什么原因在阻碍呢？还有在线上代码深层排错时，我们采用SystemTap火焰图技术来做，由于函数的名称通常会包含语义上的信息，在输出的图表中就可以轻易的按照函数名来推断问题所在，这是非常了不起的。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/loading.gif&quot; alt=&quot;&quot; class=&quot;hx_lazyimg&quot; data-original=&quot;http://amao12580.github.io/img/flameGraph.png&quot;&gt;&lt;/p&gt;
&lt;h4 id=&quot;如何做？&quot;&gt;&lt;a href=&quot;#如何做？&quot; class=&quot;headerlink&quot; title=&quot;如何做？&quot;&gt;&lt;/a&gt;如何做？&lt;/h4&gt;&lt;p&gt;具体的施行，可以参考：&lt;a href=&quot;http://blog.csdn.net/yzmyyff/article/details/45243261&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Google Java Style&lt;/a&gt;&lt;/p&gt;
&lt;h4 id=&quot;约定优于配置&quot;&gt;&lt;a href=&quot;#约定优于配置&quot; class=&quot;headerlink&quot; title=&quot;约定优于配置&quot;&gt;&lt;/a&gt;约定优于配置&lt;/h4&gt;&lt;p&gt;约定优于配置的目标是，团队内各成员参照约定的策略来进行开发，减少无意义的说明项，从而降低沟通成本。为降低持续学习成本和保证团队新成员快速融入，约定项不宜过多，且应该放到团队成员随意备查的地方(media wiki?)。&lt;/p&gt;
&lt;h5 id=&quot;过渡配置&quot;&gt;&lt;a href=&quot;#过渡配置&quot; class=&quot;headerlink&quot; title=&quot;过渡配置&quot;&gt;&lt;/a&gt;过渡配置&lt;/h5&gt;&lt;p&gt;Hibernate的早期版本中，将类及其属性映射到数据库上需要是在XML文件中的描述，其中大部分信息都应能够按照约定得到，如将类映射到同名的数据库表，将属性分别映射到表上的同名字段。这样的做法不仅繁琐易出错，而且可维护性低，后续的版本抛弃了XML配置文件，而是使用这些恰当的约定，对于不符合这些约定的情形，可以使用Java注解来说明。&lt;/p&gt;
&lt;p&gt;相应的从Ant到Maven的过渡，Grunt到Gulp的过渡，也都很好的体现了这个原则的正确性。&lt;/p&gt;
&lt;h5 id=&quot;改进&quot;&gt;&lt;a href=&quot;#改进&quot; class=&quot;headerlink&quot; title=&quot;改进&quot;&gt;&lt;/a&gt;改进&lt;/h5&gt;&lt;p&gt;约定优于配置（convention over configuration），也称作按约定编程，是一种软件设计范式，旨在减少软件开发人员需做决定的数量，获得简单的好处，而又不失灵活性。&lt;br&gt;本质是说，开发人员仅需规定应用中不符约定的部分。例如，如果模型中有个名为Sale的类，那么数据库中对应的表就会默认命名为sales。只有在偏离这一约定时，例如将该表命名为”products_sold”，才需写有关这个名字的配置。&lt;/p&gt;
&lt;h3 id=&quot;合理的设计&quot;&gt;&lt;a href=&quot;#合理的设计&quot; class=&quot;headerlink&quot; title=&quot;合理的设计&quot;&gt;&lt;/a&gt;合理的设计&lt;/h3&gt;&lt;p&gt;合理的设计，主要是面向软件可维护性、可扩展性提出，如果能兼顾性能和安全就更好了。设计是有成本的，如果软件的生命周期在预期内就不会太长，例如很多一次性的产品：内部MIS系统，售卖给企业后，几乎不再需要任何的维护。此时设计上就可以从简，没有必要为不会来临的维护去做基础，因此设计也是需要有一定的前瞻性。&lt;/p&gt;
&lt;h4 id=&quot;适时分层&quot;&gt;&lt;a href=&quot;#适时分层&quot; class=&quot;headerlink&quot; title=&quot;适时分层&quot;&gt;&lt;/a&gt;适时分层&lt;/h4&gt;&lt;p&gt;分层设计的好处主要是面向软件可维护性。合理的分层设计，往往将逻辑拆分为内聚的多层次，层之间的边界是清晰的。例如典型的三层设计，展示层、逻辑层、数据层。带来的好处是显而易见的，对于数据层来说，只需要对逻辑层提供访问数据的接口，具体如何访问数据，是访问文件还是RDBMS、NoSQL，与逻辑层是无关的。相应的重构起来也是局部重构即可，例如更换搜索引擎：Solr–&amp;gt;Elastic Search，只需要重构数据层的具体实现即可，上层任何代码不需要改动，这对于高复杂度的软件无疑是非常友好的。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/loading.gif&quot; alt=&quot;&quot; class=&quot;hx_lazyimg&quot; data-original=&quot;http://amao12580.github.io/img/splitLayer.png&quot;&gt;&lt;/p&gt;
&lt;p&gt;那分层对与软件可扩展性的影响呢？带来了一定程度的坏影响，新加一个业务逻辑功能，可能涉及到很多层的改造，而在Maven mutilmodule模式下，很可能层之间的代码是隔离的。这意味着，新加功能的代码量会有增多。&lt;/p&gt;
&lt;p&gt;一般来说分层设计适用于大型软件的持续构建，它依靠团队内的其它高效率手段来弥补稍低的可扩展性。它对安全和性能，并没有什么影响。&lt;/p&gt;
&lt;h4 id=&quot;避免过度设计&quot;&gt;&lt;a href=&quot;#避免过度设计&quot; class=&quot;headerlink&quot; title=&quot;避免过度设计&quot;&gt;&lt;/a&gt;避免过度设计&lt;/h4&gt;&lt;h4 id=&quot;模块化设计&quot;&gt;&lt;a href=&quot;#模块化设计&quot; class=&quot;headerlink&quot; title=&quot;模块化设计&quot;&gt;&lt;/a&gt;模块化设计&lt;/h4&gt;&lt;p&gt;模块化设计在重构时，可以将影响降到最低。达到低风险、低成本。&lt;br&gt;模块化设计对系统快速构建是一个阻碍，它要求将可预见的同类型代码复用，内聚到一个模块中。&lt;/p&gt;
&lt;h3 id=&quot;前轻后重&quot;&gt;&lt;a href=&quot;#前轻后重&quot; class=&quot;headerlink&quot; title=&quot;前轻后重&quot;&gt;&lt;/a&gt;前轻后重&lt;/h3&gt;&lt;p&gt;系统之间的调用链，前置系统轻逻辑。&lt;/p&gt;
&lt;h4 id=&quot;上轻下重，核心逻辑内敛&quot;&gt;&lt;a href=&quot;#上轻下重，核心逻辑内敛&quot; class=&quot;headerlink&quot; title=&quot;上轻下重，核心逻辑内敛&quot;&gt;&lt;/a&gt;上轻下重，核心逻辑内敛&lt;/h4&gt;&lt;p&gt;模块之间的调用链，上层模块轻逻辑&lt;/p&gt;
&lt;h3 id=&quot;基础优先&quot;&gt;&lt;a href=&quot;#基础优先&quot; class=&quot;headerlink&quot; title=&quot;基础优先&quot;&gt;&lt;/a&gt;基础优先&lt;/h3&gt;&lt;p&gt;在构建软件时，保持基础组件优先稳定下来，定义好对外接口，并保留可扩展性。&lt;br&gt;例如安全性设计，在后期加比在前期加的成本高很多。&lt;/p&gt;
&lt;h3 id=&quot;最小冗余&quot;&gt;&lt;a href=&quot;#最小冗余&quot; class=&quot;headerlink&quot; title=&quot;最小冗余&quot;&gt;&lt;/a&gt;最小冗余&lt;/h3&gt;&lt;h4 id=&quot;代码保持最少行数&quot;&gt;&lt;a href=&quot;#代码保持最少行数&quot; class=&quot;headerlink&quot; title=&quot;代码保持最少行数&quot;&gt;&lt;/a&gt;代码保持最少行数&lt;/h4&gt;&lt;p&gt;1.少一行代码，就少了一个潜在的bug&lt;br&gt;2.行数少了，往往意味着重用性高了&lt;br&gt;3.不要过度牺牲可读性&lt;/p&gt;
&lt;h3 id=&quot;保持简单&quot;&gt;&lt;a href=&quot;#保持简单&quot; class=&quot;headerlink&quot; title=&quot;保持简单&quot;&gt;&lt;/a&gt;保持简单&lt;/h3&gt;&lt;h4 id=&quot;简单意味着快速&quot;&gt;&lt;a href=&quot;#简单意味着快速&quot; class=&quot;headerlink&quot; title=&quot;简单意味着快速&quot;&gt;&lt;/a&gt;简单意味着快速&lt;/h4&gt;&lt;h4 id=&quot;简单意味着灵活&quot;&gt;&lt;a href=&quot;#简单意味着灵活&quot; class=&quot;headerlink&quot; title=&quot;简单意味着灵活&quot;&gt;&lt;/a&gt;简单意味着灵活&lt;/h4&gt;&lt;h4 id=&quot;简单意味着易扩展&quot;&gt;&lt;a href=&quot;#简单意味着易扩展&quot; class=&quot;headerlink&quot; title=&quot;简单意味着易扩展&quot;&gt;&lt;/a&gt;简单意味着易扩展&lt;/h4&gt;&lt;h4 id=&quot;简单意味着易重构&quot;&gt;&lt;a href=&quot;#简单意味着易重构&quot; class=&quot;headerlink&quot; title=&quot;简单意味着易重构&quot;&gt;&lt;/a&gt;简单意味着易重构&lt;/h4&gt;&lt;h3 id=&quot;Fast-fail&quot;&gt;&lt;a href=&quot;#Fast-fail&quot; class=&quot;headerlink&quot; title=&quot;Fast fail&quot;&gt;&lt;/a&gt;Fast fail&lt;/h3&gt;&lt;h3 id=&quot;代码即文档&quot;&gt;&lt;a href=&quot;#代码即文档&quot; class=&quot;headerlink&quot; title=&quot;代码即文档&quot;&gt;&lt;/a&gt;代码即文档&lt;/h3&gt;&lt;h4 id=&quot;合理的注释&quot;&gt;&lt;a href=&quot;#合理的注释&quot; class=&quot;headerlink&quot; title=&quot;合理的注释&quot;&gt;&lt;/a&gt;合理的注释&lt;/h4&gt;&lt;h3 id=&quot;关键业务设计宣讲&quot;&gt;&lt;a href=&quot;#关键业务设计宣讲&quot; class=&quot;headerlink&quot; title=&quot;关键业务设计宣讲&quot;&gt;&lt;/a&gt;关键业务设计宣讲&lt;/h3&gt;&lt;h4 id=&quot;保持一致的看法&quot;&gt;&lt;a href=&quot;#保持一致的看法&quot; class=&quot;headerlink&quot; title=&quot;保持一致的看法&quot;&gt;&lt;/a&gt;保持一致的看法&lt;/h4&gt;&lt;h3 id=&quot;小步快走&quot;&gt;&lt;a href=&quot;#小步快走&quot; class=&quot;headerlink&quot; title=&quot;小步快走&quot;&gt;&lt;/a&gt;小步快走&lt;/h3&gt;&lt;h4 id=&quot;意味着版本迭代快速&quot;&gt;&lt;a href=&quot;#意味着版本迭代快速&quot; class=&quot;headerlink&quot; title=&quot;意味着版本迭代快速&quot;&gt;&lt;/a&gt;意味着版本迭代快速&lt;/h4&gt;&lt;h4 id=&quot;意味着版本迭代稳定&quot;&gt;&lt;a href=&quot;#意味着版本迭代稳定&quot; class=&quot;headerlink&quot; title=&quot;意味着版本迭代稳定&quot;&gt;&lt;/a&gt;意味着版本迭代稳定&lt;/h4&gt;&lt;h4 id=&quot;意味着部署回滚成本低&quot;&gt;&lt;a href=&quot;#意味着部署回滚成本低&quot; class=&quot;headerlink&quot; title=&quot;意味着部署回滚成本低&quot;&gt;&lt;/a&gt;意味着部署回滚成本低&lt;/h4&gt;&lt;h2 id=&quot;重构与优化&quot;&gt;&lt;a href=&quot;#重构与优化&quot; class=&quot;headerlink&quot; title=&quot;重构与优化&quot;&gt;&lt;/a&gt;重构与优化&lt;/h2&gt;&lt;h3 id=&quot;紧急优先&quot;&gt;&lt;a href=&quot;#紧急优先&quot; class=&quot;headerlink&quot; title=&quot;紧急优先&quot;&gt;&lt;/a&gt;紧急优先&lt;/h3&gt;&lt;p&gt;优先对紧急需要改进的部分进行重构&lt;/p&gt;
&lt;h3 id=&quot;计划性的重构&quot;&gt;&lt;a href=&quot;#计划性的重构&quot; class=&quot;headerlink&quot; title=&quot;计划性的重构&quot;&gt;&lt;/a&gt;计划性的重构&lt;/h3&gt;&lt;p&gt;在敏捷开发时，往往时间不够，有些模块只能以非优雅的方式构建。但是需要在这些模块加上TODO以免重构时遗忘。&lt;/p&gt;
&lt;h3 id=&quot;时机&quot;&gt;&lt;a href=&quot;#时机&quot; class=&quot;headerlink&quot; title=&quot;时机&quot;&gt;&lt;/a&gt;时机&lt;/h3&gt;&lt;p&gt;团队一致认为模块维护成本高昂时，果断重构。&lt;/p&gt;
&lt;h3 id=&quot;基于成本的优化&quot;&gt;&lt;a href=&quot;#基于成本的优化&quot; class=&quot;headerlink&quot; title=&quot;基于成本的优化&quot;&gt;&lt;/a&gt;基于成本的优化&lt;/h3&gt;&lt;p&gt;CBO(Cost base optimize)&lt;/p&gt;
&lt;p&gt;引用数据库查询分析计划来说明：&lt;a href=&quot;http://blog.jobbole.com/100349&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;如果有人问你数据库的原理，叫他看这篇文章#查询优化器&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;数据支撑&quot;&gt;&lt;a href=&quot;#数据支撑&quot; class=&quot;headerlink&quot; title=&quot;数据支撑&quot;&gt;&lt;/a&gt;数据支撑&lt;/h3&gt;&lt;p&gt;给出重构前后的成本与收益报告&lt;/p&gt;
&lt;h3 id=&quot;持续性&quot;&gt;&lt;a href=&quot;#持续性&quot; class=&quot;headerlink&quot; title=&quot;持续性&quot;&gt;&lt;/a&gt;持续性&lt;/h3&gt;&lt;p&gt;在时间不够或时机不成熟时，分阶段的进行&lt;/p&gt;
&lt;h2 id=&quot;技术选型&quot;&gt;&lt;a href=&quot;#技术选型&quot; class=&quot;headerlink&quot; title=&quot;技术选型&quot;&gt;&lt;/a&gt;技术选型&lt;/h2&gt;&lt;h3 id=&quot;开源优先&quot;&gt;&lt;a href=&quot;#开源优先&quot; class=&quot;headerlink&quot; title=&quot;开源优先&quot;&gt;&lt;/a&gt;开源优先&lt;/h3&gt;&lt;h3 id=&quot;稳定优先&quot;&gt;&lt;a href=&quot;#稳定优先&quot; class=&quot;headerlink&quot; title=&quot;稳定优先&quot;&gt;&lt;/a&gt;稳定优先&lt;/h3&gt;&lt;h3 id=&quot;掌控度高优先&quot;&gt;&lt;a href=&quot;#掌控度高优先&quot; class=&quot;headerlink&quot; title=&quot;掌控度高优先&quot;&gt;&lt;/a&gt;掌控度高优先&lt;/h3&gt;&lt;h3 id=&quot;保留备选项&quot;&gt;&lt;a href=&quot;#保留备选项&quot; class=&quot;headerlink&quot; title=&quot;保留备选项&quot;&gt;&lt;/a&gt;保留备选项&lt;/h3&gt;&lt;h3 id=&quot;只有合适的技术，没有最好的技术。&quot;&gt;&lt;a href=&quot;#只有合适的技术，没有最好的技术。&quot; class=&quot;headerlink&quot; title=&quot;只有合适的技术，没有最好的技术。&quot;&gt;&lt;/a&gt;只有合适的技术，没有最好的技术。&lt;/h3&gt;&lt;h3 id=&quot;避免一招鲜吃遍天&quot;&gt;&lt;a href=&quot;#避免一招鲜吃遍天&quot; class=&quot;headerlink&quot; title=&quot;避免一招鲜吃遍天&quot;&gt;&lt;/a&gt;避免一招鲜吃遍天&lt;/h3&gt;&lt;p&gt;手里有锤子，看到什么都觉得像钉子&lt;/p&gt;
&lt;h3 id=&quot;技术升级&quot;&gt;&lt;a href=&quot;#技术升级&quot; class=&quot;headerlink&quot; title=&quot;技术升级&quot;&gt;&lt;/a&gt;技术升级&lt;/h3&gt;&lt;p&gt;系统容量与性能指标的要求，在业务发展的各个阶段是不固定的，技术需要保留一定前瞻性，不做被动跟随。&lt;/p&gt;
&lt;h2 id=&quot;接口&quot;&gt;&lt;a href=&quot;#接口&quot; class=&quot;headerlink&quot; title=&quot;接口&quot;&gt;&lt;/a&gt;接口&lt;/h2&gt;&lt;h3 id=&quot;版本控制&quot;&gt;&lt;a href=&quot;#版本控制&quot; class=&quot;headerlink&quot; title=&quot;版本控制&quot;&gt;&lt;/a&gt;版本控制&lt;/h3&gt;&lt;h3 id=&quot;访问控制&quot;&gt;&lt;a href=&quot;#访问控制&quot; class=&quot;headerlink&quot; title=&quot;访问控制&quot;&gt;&lt;/a&gt;访问控制&lt;/h3&gt;&lt;p&gt;访问权限的验证&lt;/p&gt;
&lt;h3 id=&quot;流量控制&quot;&gt;&lt;a href=&quot;#流量控制&quot; class=&quot;headerlink&quot; title=&quot;流量控制&quot;&gt;&lt;/a&gt;流量控制&lt;/h3&gt;&lt;p&gt;拒绝恶意访问&lt;/p&gt;
&lt;h3 id=&quot;审查与监控&quot;&gt;&lt;a href=&quot;#审查与监控&quot; class=&quot;headerlink&quot; title=&quot;审查与监控&quot;&gt;&lt;/a&gt;审查与监控&lt;/h3&gt;&lt;h3 id=&quot;灰度发布&quot;&gt;&lt;a href=&quot;#灰度发布&quot; class=&quot;headerlink&quot; title=&quot;灰度发布&quot;&gt;&lt;/a&gt;灰度发布&lt;/h3&gt;&lt;h3 id=&quot;无状态&quot;&gt;&lt;a href=&quot;#无状态&quot; class=&quot;headerlink&quot; title=&quot;无状态&quot;&gt;&lt;/a&gt;无状态&lt;/h3&gt;&lt;h3 id=&quot;原子化&quot;&gt;&lt;a href=&quot;#原子化&quot; class=&quot;headerlink&quot; title=&quot;原子化&quot;&gt;&lt;/a&gt;原子化&lt;/h3&gt;&lt;h3 id=&quot;CQRS&quot;&gt;&lt;a href=&quot;#CQRS&quot; class=&quot;headerlink&quot; title=&quot;CQRS&quot;&gt;&lt;/a&gt;CQRS&lt;/h3&gt;&lt;p&gt;命令查询职责分离模式，读不强依赖写。&lt;/p&gt;
&lt;h2 id=&quot;外部接口&quot;&gt;&lt;a href=&quot;#外部接口&quot; class=&quot;headerlink&quot; title=&quot;外部接口&quot;&gt;&lt;/a&gt;外部接口&lt;/h2&gt;&lt;h3 id=&quot;合理调用&quot;&gt;&lt;a href=&quot;#合理调用&quot; class=&quot;headerlink&quot; title=&quot;合理调用&quot;&gt;&lt;/a&gt;合理调用&lt;/h3&gt;&lt;p&gt;同步VS异步&lt;br&gt;批量VS单个  批量：局部失败&lt;/p&gt;
&lt;h3 id=&quot;保持怀疑&quot;&gt;&lt;a href=&quot;#保持怀疑&quot; class=&quot;headerlink&quot; title=&quot;保持怀疑&quot;&gt;&lt;/a&gt;保持怀疑&lt;/h3&gt;&lt;h4 id=&quot;兜底方案&quot;&gt;&lt;a href=&quot;#兜底方案&quot; class=&quot;headerlink&quot; title=&quot;兜底方案&quot;&gt;&lt;/a&gt;兜底方案&lt;/h4&gt;&lt;p&gt;如果有可能，在外部接口调用失败时，读取本地上一次调用成功的缓存。例如：加载和更新广告，CDN访问失败进行回源。&lt;/p&gt;
&lt;p&gt;进行兜底时，注意将失败的信息进行记录以便告警&lt;/p&gt;
&lt;h2 id=&quot;APP&quot;&gt;&lt;a href=&quot;#APP&quot; class=&quot;headerlink&quot; title=&quot;APP&quot;&gt;&lt;/a&gt;APP&lt;/h2&gt;&lt;h3 id=&quot;远程控制权&quot;&gt;&lt;a href=&quot;#远程控制权&quot; class=&quot;headerlink&quot; title=&quot;远程控制权&quot;&gt;&lt;/a&gt;远程控制权&lt;/h3&gt;&lt;h3 id=&quot;展示为主&quot;&gt;&lt;a href=&quot;#展示为主&quot; class=&quot;headerlink&quot; title=&quot;展示为主&quot;&gt;&lt;/a&gt;展示为主&lt;/h3&gt;&lt;h3 id=&quot;少的逻辑&quot;&gt;&lt;a href=&quot;#少的逻辑&quot; class=&quot;headerlink&quot; title=&quot;少的逻辑&quot;&gt;&lt;/a&gt;少的逻辑&lt;/h3&gt;&lt;h3 id=&quot;适度安全&quot;&gt;&lt;a href=&quot;#适度安全&quot; class=&quot;headerlink&quot; title=&quot;适度安全&quot;&gt;&lt;/a&gt;适度安全&lt;/h3&gt;&lt;h2 id=&quot;部署&quot;&gt;&lt;a href=&quot;#部署&quot; class=&quot;headerlink&quot; title=&quot;部署&quot;&gt;&lt;/a&gt;部署&lt;/h2&gt;&lt;h3 id=&quot;监控&quot;&gt;&lt;a href=&quot;#监控&quot; class=&quot;headerlink&quot; title=&quot;监控&quot;&gt;&lt;/a&gt;监控&lt;/h3&gt;&lt;h3 id=&quot;降低升级时间窗&quot;&gt;&lt;a href=&quot;#降低升级时间窗&quot; class=&quot;headerlink&quot; title=&quot;降低升级时间窗&quot;&gt;&lt;/a&gt;降低升级时间窗&lt;/h3&gt;&lt;h3 id=&quot;没有人需要等待&quot;&gt;&lt;a href=&quot;#没有人需要等待&quot; class=&quot;headerlink&quot; title=&quot;没有人需要等待&quot;&gt;&lt;/a&gt;没有人需要等待&lt;/h3&gt;&lt;p&gt;正式发布后，对于任何用户都是公平使用的。不需要牺牲部分用户利益。&lt;br&gt;常见于缓存autowarm时需要阻塞第一批到达的用户。&lt;/p&gt;
&lt;h3 id=&quot;提前消除隐患&quot;&gt;&lt;a href=&quot;#提前消除隐患&quot; class=&quot;headerlink&quot; title=&quot;提前消除隐患&quot;&gt;&lt;/a&gt;提前消除隐患&lt;/h3&gt;&lt;h1 id=&quot;团队管理&quot;&gt;&lt;a href=&quot;#团队管理&quot; class=&quot;headerlink&quot; title=&quot;团队管理&quot;&gt;&lt;/a&gt;团队管理&lt;/h1&gt;&lt;p&gt;精细化管理&lt;/p&gt;
&lt;h2 id=&quot;keep-watch&quot;&gt;&lt;a href=&quot;#keep-watch&quot; class=&quot;headerlink&quot; title=&quot;keep watch&quot;&gt;&lt;/a&gt;keep watch&lt;/h2&gt;&lt;p&gt;工作与心理的交流分享&lt;/p&gt;
&lt;h2 id=&quot;保持信任&quot;&gt;&lt;a href=&quot;#保持信任&quot; class=&quot;headerlink&quot; title=&quot;保持信任&quot;&gt;&lt;/a&gt;保持信任&lt;/h2&gt;&lt;h2 id=&quot;保持怀疑-1&quot;&gt;&lt;a href=&quot;#保持怀疑-1&quot; class=&quot;headerlink&quot; title=&quot;保持怀疑&quot;&gt;&lt;/a&gt;保持怀疑&lt;/h2&gt;&lt;h2 id=&quot;持续考评&quot;&gt;&lt;a href=&quot;#持续考评&quot; class=&quot;headerlink&quot; title=&quot;持续考评&quot;&gt;&lt;/a&gt;持续考评&lt;/h2&gt;&lt;h2 id=&quot;分享中提高&quot;&gt;&lt;a href=&quot;#分享中提高&quot; class=&quot;headerlink&quot; title=&quot;分享中提高&quot;&gt;&lt;/a&gt;分享中提高&lt;/h2&gt;&lt;p&gt;有一个著名的理论，叫木桶理论。意思是木桶能装多少水，是由木桶最短的那个板来决定的。团队也是如此。团队的力量有多大，很多时候也是由能力最差的那个成员来决定的。为了提高团队整体的实力，我们必须提高每个人的能力。我们的改善必须得是可度量的，所以我们也要数字化能力的标准。&lt;/p&gt;
&lt;h2 id=&quot;提高工作效率&quot;&gt;&lt;a href=&quot;#提高工作效率&quot; class=&quot;headerlink&quot; title=&quot;提高工作效率&quot;&gt;&lt;/a&gt;提高工作效率&lt;/h2&gt;&lt;p&gt;其实很多团队都在进行着这个工作。最常见的就是会做一些小工具，来节省我们的时间。比如代码自动生成工具，自动打包工具，自动的比较工具等等。我们应该制作尽可能多的自动化工具，来解放我们的时间。&lt;/p&gt;
&lt;p&gt;为了让大家投入更多的热情来制作各种工具，团队可以制定一定的奖励规则，对制作工具的人给予奖励。&lt;/p&gt;
&lt;p&gt;公司要把最好的人才放到工具开发那一块，因为工具做好了，可以达到事半功倍的效果，所有人的效率都可以得到提高，而不仅仅是工程师。&lt;/p&gt;
&lt;h2 id=&quot;互相备份&quot;&gt;&lt;a href=&quot;#互相备份&quot; class=&quot;headerlink&quot; title=&quot;互相备份&quot;&gt;&lt;/a&gt;互相备份&lt;/h2&gt;&lt;h2 id=&quot;互相支撑&quot;&gt;&lt;a href=&quot;#互相支撑&quot; class=&quot;headerlink&quot; title=&quot;互相支撑&quot;&gt;&lt;/a&gt;互相支撑&lt;/h2&gt;&lt;h2 id=&quot;向上管理&quot;&gt;&lt;a href=&quot;#向上管理&quot; class=&quot;headerlink&quot; title=&quot;向上管理&quot;&gt;&lt;/a&gt;向上管理&lt;/h2&gt;&lt;h2 id=&quot;向下管理&quot;&gt;&lt;a href=&quot;#向下管理&quot; class=&quot;headerlink&quot; title=&quot;向下管理&quot;&gt;&lt;/a&gt;向下管理&lt;/h2&gt;&lt;h3 id=&quot;了解队员的擅长与不足&quot;&gt;&lt;a href=&quot;#了解队员的擅长与不足&quot; class=&quot;headerlink&quot; title=&quot;了解队员的擅长与不足&quot;&gt;&lt;/a&gt;了解队员的擅长与不足&lt;/h3&gt;&lt;h3 id=&quot;合理的任务分配&quot;&gt;&lt;a href=&quot;#合理的任务分配&quot; class=&quot;headerlink&quot; title=&quot;合理的任务分配&quot;&gt;&lt;/a&gt;合理的任务分配&lt;/h3&gt;&lt;h3 id=&quot;适度挑战性的任务&quot;&gt;&lt;a href=&quot;#适度挑战性的任务&quot; class=&quot;headerlink&quot; title=&quot;适度挑战性的任务&quot;&gt;&lt;/a&gt;适度挑战性的任务&lt;/h3&gt;&lt;h3 id=&quot;给出完成任务需要的资源&quot;&gt;&lt;a href=&quot;#给出完成任务需要的资源&quot; class=&quot;headerlink&quot; title=&quot;给出完成任务需要的资源&quot;&gt;&lt;/a&gt;给出完成任务需要的资源&lt;/h3&gt;&lt;h3 id=&quot;激励中成长&quot;&gt;&lt;a href=&quot;#激励中成长&quot; class=&quot;headerlink&quot; title=&quot;激励中成长&quot;&gt;&lt;/a&gt;激励中成长&lt;/h3&gt;&lt;p&gt;眼前利益与发展前景&lt;/p&gt;
&lt;h3 id=&quot;给出职业发展的机会&quot;&gt;&lt;a href=&quot;#给出职业发展的机会&quot; class=&quot;headerlink&quot; title=&quot;给出职业发展的机会&quot;&gt;&lt;/a&gt;给出职业发展的机会&lt;/h3&gt;&lt;h3 id=&quot;公开与公平中考评&quot;&gt;&lt;a href=&quot;#公开与公平中考评&quot; class=&quot;headerlink&quot; title=&quot;公开与公平中考评&quot;&gt;&lt;/a&gt;公开与公平中考评&lt;/h3&gt;&lt;h3 id=&quot;保持团队稳定&quot;&gt;&lt;a href=&quot;#保持团队稳定&quot; class=&quot;headerlink&quot; title=&quot;保持团队稳定&quot;&gt;&lt;/a&gt;保持团队稳定&lt;/h3&gt;&lt;p&gt;团队成员的诉求：团队，产品，薪资，发展。&lt;/p&gt;
&lt;p&gt;团队提供集体成长的氛围环境。&lt;/p&gt;
&lt;p&gt;令人兴奋的产品，提供持续打磨的动力。&lt;/p&gt;
&lt;p&gt;合适的薪资，使个人不过多为生活所扰。&lt;/p&gt;
&lt;p&gt;良好的发展前景，对个人的职业生涯带来腾飞。&lt;/p&gt;
&lt;p&gt;“穷得只剩钱”。小公司对企业文化不慎重视，开发团队的整体风气也没要求，招人过来只求出活，对团队个人发展是零投入的态度。这样的企业要想招到人、留住人，只剩钱了，但个人发展到一定高度，往往企业再也给不出足够的钱，这时再想留住人就很难了。这就是企业只依靠薪资吸引人带来的问题，对其他人才诉求不重视，穷得只剩钱。&lt;/p&gt;
&lt;p&gt;当收入待遇和地位与自身才能不匹配时候，离开几乎是个必然的选择。&lt;/p&gt;
&lt;h2 id=&quot;适时剔除不合格&quot;&gt;&lt;a href=&quot;#适时剔除不合格&quot; class=&quot;headerlink&quot; title=&quot;适时剔除不合格&quot;&gt;&lt;/a&gt;适时剔除不合格&lt;/h2&gt;&lt;h2 id=&quot;技术梯队&quot;&gt;&lt;a href=&quot;#技术梯队&quot; class=&quot;headerlink&quot; title=&quot;技术梯队&quot;&gt;&lt;/a&gt;技术梯队&lt;/h2&gt;&lt;p&gt;不同层次的人员配比，完成不同类型的任务。注意人员的上升下降渠道。&lt;/p&gt;
&lt;h1 id=&quot;Reference&quot;&gt;&lt;a href=&quot;#Reference&quot; class=&quot;headerlink&quot; title=&quot;Reference&quot;&gt;&lt;/a&gt;Reference&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://blogread.cn/it/article/7346?f=wb&amp;amp;utm_source=top.caibaojian.com/102758&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;以Facebook为案例剖析科技公司应有的工具文化&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MjM5ODQ2MDIyMA==&amp;amp;mid=2650712266&amp;amp;idx=1&amp;amp;sn=54d909d240eb701ae48467dc798ddc7f&amp;amp;scene=2&amp;amp;srcid=0506gUskHi8qJi6joV2483uM&amp;amp;from=timeline&amp;amp;isappinstalled=0#wechat_redirect&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;动态追踪技术（中） - Dtrace、SystemTap、火焰图&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://zh.wikipedia.org/wiki/%E6%9E%81%E9%99%90%E7%BC%96%E7%A8%8B&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;极限编程&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</content>
    
    <summary type="html">
    
      技术人员乐于被领导；但他们不喜欢被管理，不喜欢像牛一样被驱赶或指挥。管理者强迫人们服从他们的命令，而领导者则会带领他们一起工作。管理是客观的，没有个人感情因素，它假定被管理者没有思想和感受，被告知要做什么和该如何做。领导是引领、引导，它激励人们达成目标。领导力是带有强烈个人感情色彩的，它不是你能命令的，也不是你能测量评估和测试的。
    
    </summary>
    
      <category term="Summary" scheme="http://amao12580.github.io/categories/Summary/"/>
    
    
      <category term="Management" scheme="http://amao12580.github.io/tags/Management/"/>
    
      <category term="Specification" scheme="http://amao12580.github.io/tags/Specification/"/>
    
  </entry>
  
</feed>
