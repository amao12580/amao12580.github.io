<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Cat&#39;s Blog</title>
  <subtitle>一饮一啄，莫非前定.</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://amao12580.github.io/"/>
  <updated>2016-06-12T02:31:38.775Z</updated>
  <id>http://amao12580.github.io/</id>
  
  <author>
    <name>Steven Cheng</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>消息系统的架构演进之路</title>
    <link href="http://amao12580.github.io/post/2016/06/Message-system-architecture-evolution/"/>
    <id>http://amao12580.github.io/post/2016/06/Message-system-architecture-evolution/</id>
    <published>2016-06-01T05:18:41.875Z</published>
    <updated>2016-06-12T02:31:38.775Z</updated>
    
    <content type="html">&lt;p&gt;暂时未完成&lt;/p&gt;
&lt;h1 id=&quot;写在前面&quot;&gt;&lt;a href=&quot;#写在前面&quot; class=&quot;headerlink&quot; title=&quot;写在前面&quot;&gt;&lt;/a&gt;写在前面&lt;/h1&gt;&lt;h1 id=&quot;1-0版架构的问题&quot;&gt;&lt;a href=&quot;#1-0版架构的问题&quot; class=&quot;headerlink&quot; title=&quot;1.0版架构的问题&quot;&gt;&lt;/a&gt;1.0版架构的问题&lt;/h1&gt;&lt;h2 id=&quot;详细说明&quot;&gt;&lt;a href=&quot;#详细说明&quot; class=&quot;headerlink&quot; title=&quot;详细说明&quot;&gt;&lt;/a&gt;详细说明&lt;/h2&gt;&lt;h2 id=&quot;缺陷&quot;&gt;&lt;a href=&quot;#缺陷&quot; class=&quot;headerlink&quot; title=&quot;缺陷&quot;&gt;&lt;/a&gt;缺陷&lt;/h2&gt;&lt;h2 id=&quot;优势&quot;&gt;&lt;a href=&quot;#优势&quot; class=&quot;headerlink&quot; title=&quot;优势&quot;&gt;&lt;/a&gt;优势&lt;/h2&gt;&lt;h1 id=&quot;2-0版如何改进？&quot;&gt;&lt;a href=&quot;#2-0版如何改进？&quot; class=&quot;headerlink&quot; title=&quot;2.0版如何改进？&quot;&gt;&lt;/a&gt;2.0版如何改进？&lt;/h1&gt;&lt;h2 id=&quot;详细说明-1&quot;&gt;&lt;a href=&quot;#详细说明-1&quot; class=&quot;headerlink&quot; title=&quot;详细说明&quot;&gt;&lt;/a&gt;详细说明&lt;/h2&gt;&lt;h2 id=&quot;缺陷-1&quot;&gt;&lt;a href=&quot;#缺陷-1&quot; class=&quot;headerlink&quot; title=&quot;缺陷&quot;&gt;&lt;/a&gt;缺陷&lt;/h2&gt;&lt;h2 id=&quot;优势-1&quot;&gt;&lt;a href=&quot;#优势-1&quot; class=&quot;headerlink&quot; title=&quot;优势&quot;&gt;&lt;/a&gt;优势&lt;/h2&gt;&lt;h1 id=&quot;展望3-0版&quot;&gt;&lt;a href=&quot;#展望3-0版&quot; class=&quot;headerlink&quot; title=&quot;展望3.0版&quot;&gt;&lt;/a&gt;展望3.0版&lt;/h1&gt;&lt;h2 id=&quot;详细说明-2&quot;&gt;&lt;a href=&quot;#详细说明-2&quot; class=&quot;headerlink&quot; title=&quot;详细说明&quot;&gt;&lt;/a&gt;详细说明&lt;/h2&gt;&lt;h2 id=&quot;缺陷-2&quot;&gt;&lt;a href=&quot;#缺陷-2&quot; class=&quot;headerlink&quot; title=&quot;缺陷&quot;&gt;&lt;/a&gt;缺陷&lt;/h2&gt;&lt;h2 id=&quot;优势-2&quot;&gt;&lt;a href=&quot;#优势-2&quot; class=&quot;headerlink&quot; title=&quot;优势&quot;&gt;&lt;/a&gt;优势&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;/images/loading.gif&quot; alt=&quot;&quot; class=&quot;hx_lazyimg&quot; data-original=&quot;http://amao12580.github.io/img/03-消息系统改进1阶段的总体结构.jpg&quot;&gt;&lt;/p&gt;
</content>
    
    <summary type="html">
    
      消息系统在分阶段的架构演进
    
    </summary>
    
      <category term="Summary" scheme="http://amao12580.github.io/categories/Summary/"/>
    
    
      <category term="MessageSystem" scheme="http://amao12580.github.io/tags/MessageSystem/"/>
    
      <category term="architecture" scheme="http://amao12580.github.io/tags/architecture/"/>
    
  </entry>
  
  <entry>
    <title>当我们谈事务时，我们在谈什么？</title>
    <link href="http://amao12580.github.io/post/2016/06/What-is-a-transaction/"/>
    <id>http://amao12580.github.io/post/2016/06/What-is-a-transaction/</id>
    <published>2016-06-01T05:01:50.068Z</published>
    <updated>2016-06-13T06:01:50.058Z</updated>
    
    <content type="html">&lt;p&gt;暂时未完成&lt;/p&gt;
&lt;h2 id=&quot;写在前面&quot;&gt;&lt;a href=&quot;#写在前面&quot; class=&quot;headerlink&quot; title=&quot;写在前面&quot;&gt;&lt;/a&gt;写在前面&lt;/h2&gt;&lt;p&gt;写这篇文章的初衷是记录和总结关于事务的方方面面，还记得以前在面试高工时，被问到数据库事务的实现原理是什么？答了读写锁和表锁，以及myisam和innodb引擎在事务隔离级别的差异。当时面试官不是很满意，自然那家公司最终也没有谈成。面试完了，这个问题却一直萦绕在脑海中挥之不去，经过自己对存储引擎知识的补全，才知道原来事务是这样的妙不可言。如果读者需要对数据库事务进行系统的学习，我推荐一本书&lt;a href=&quot;https://www.amazon.cn/MySQL%E6%8A%80%E6%9C%AF%E5%86%85%E5%B9%95-InnoDB%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E-%E5%A7%9C%E6%89%BF%E5%B0%A7/dp/B00ETOV48K/ref=sr_1_1?s=digital-text&amp;amp;ie=UTF8&amp;amp;qid=1465707176&amp;amp;sr=1-1&amp;amp;keywords=MySQL%E6%8A%80%E6%9C%AF%E5%86%85%E5%B9%95%EF%BC%9AInnoDB%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;《MySQL技术内幕  InnoDB存储引擎 第2版》&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;讨论传统关系型数据库内的事务，以及如何与NoSQL领域结合进行事务化。&lt;/p&gt;
&lt;h2 id=&quot;什么是事务？&quot;&gt;&lt;a href=&quot;#什么是事务？&quot; class=&quot;headerlink&quot; title=&quot;什么是事务？&quot;&gt;&lt;/a&gt;什么是事务？&lt;/h2&gt;&lt;p&gt;数据库事务（简称：事务）是数据库管理系统执行过程中的一个逻辑单位，由一个有限的数据库操作序列构成。这是使用Google Search以“事务”为关键字查找时，第一条是wikipedia给出的描述。通俗地讲，事务就是通过一系列操作来完成一件事情，在进行这些操作的过程中，要么这些操作完全执行，要么这些操作全不执行，不存在中间状态，事务分为事务执行阶段和事务提交阶段。&lt;/p&gt;
&lt;h3 id=&quot;与文件系统的差异&quot;&gt;&lt;a href=&quot;#与文件系统的差异&quot; class=&quot;headerlink&quot; title=&quot;与文件系统的差异&quot;&gt;&lt;/a&gt;与文件系统的差异&lt;/h3&gt;&lt;p&gt;以MySQL数据库系统为例，数据被按页（16K）存储在磁盘中，如何组织数据的存储格式，由存储引擎来定义。在数据被插入或修改时，为了提高TPS，规避磁盘写入缓慢的问题，MySQL会将新数据页缓冲到内存（Insert Buffer），达到一定时间，或者积累的数据达到一定量级后，会由Master Thread刷入磁盘，同时清空缓冲区（CheckPoint机制）。在数据需要读取时，先从磁盘按页读取，如果有配置缓冲池，这些取出的数据还会在内存中留一个副本（FIX），只要数据不进行修改，下次读取时就会冲缓冲池命中了，大大加快了访问速度。&lt;/p&gt;
&lt;p&gt;看到这里，我们不经有疑问，在内存与磁盘上，读、写、组织数据，这不是文件系统在干的事情吗？的确，在NTFS、Ext4等文件系统中，这些功能都是被支持的。数据库系统是基于文件系统的，按照不同文件系统(包括不同的操作系统内存分配算法)，在底层调用了不同的API进行数据的读、写、组织。但它最重要的特性是事务的支持，允许有限个的数据库操作进行逻辑单元化，解决文件系统访问无状态的问题。同时也是由于事务一致性的支持，数据库系统相较于文件系统的性能普遍是下降的，隔离级别的支持越高（更强的一致性），性能下降越是厉害。&lt;/p&gt;
&lt;h2 id=&quot;本地事务&quot;&gt;&lt;a href=&quot;#本地事务&quot; class=&quot;headerlink&quot; title=&quot;本地事务&quot;&gt;&lt;/a&gt;本地事务&lt;/h2&gt;&lt;p&gt;不同的数据库系统有不同的事务行为。有些数据库系统根本不支持事务。有些数据库系统支持事务，但是不支持双向提交（2PC）协议。这类事务被称为支持本地事务。有些数据库系统既支持本地事务，又支持 2PC。这类事务被称为支持分布式事务，或者全局事务。全局事务也被称为 XA 事务，因为它们包含 XAResource接口。&lt;/p&gt;
&lt;h3 id=&quot;ACID&quot;&gt;&lt;a href=&quot;#ACID&quot; class=&quot;headerlink&quot; title=&quot;ACID&quot;&gt;&lt;/a&gt;ACID&lt;/h3&gt;&lt;p&gt;一般说到事务，就会想到它的特性— ACID，那么什么是 ACID 呢？我们先用一个现实中的例子来说明：AB 两同学在同一家银行ZSBANK的账号都有 1,000 块钱，A 通过ZSBANK银行转账向 B 转了 100 块钱，这个事务分为两个操作,即从 A 同学账号扣除 100，向 B 同学账号增加 100。&lt;/p&gt;
&lt;p&gt;对于应用层程序的同一个线程X来说，逻辑伪码如下：&lt;/p&gt;
&lt;figure class=&quot;highlight cs&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;30&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;double&lt;/span&gt; transferAmount=&lt;span class=&quot;number&quot;&gt;100.00&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//1.开始事务&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//2.检查A同学账户余额是否大于100元&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;double&lt;/span&gt; balanceForA=&lt;span class=&quot;keyword&quot;&gt;select&lt;/span&gt; account.balance &lt;span class=&quot;keyword&quot;&gt;from&lt;/span&gt; account &lt;span class=&quot;keyword&quot;&gt;where&lt;/span&gt; uid=A;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;(transferAmount&amp;gt;balanceForA)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; ErrorResult(&lt;span class=&quot;number&quot;&gt;100&lt;/span&gt;,&lt;span class=&quot;string&quot;&gt;&quot;账户余额不足.&quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//3.将A同学账户扣款100元&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; deductRet=update account &lt;span class=&quot;keyword&quot;&gt;set&lt;/span&gt; balance=balance-transferAmount &lt;span class=&quot;keyword&quot;&gt;where&lt;/span&gt; uid=A and balance &amp;gt;=transferAmount;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;(deductRet==&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    LogHelper.info(&lt;span class=&quot;string&quot;&gt;&quot;account A deduct &quot;&lt;/span&gt;+transferAmount+&lt;span class=&quot;string&quot;&gt;&quot; success.&quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; ErrorResult(&lt;span class=&quot;number&quot;&gt;200&lt;/span&gt;,&lt;span class=&quot;string&quot;&gt;&quot;账户扣款失败.&quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//4.将B同学账户增加100元&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; deductRet=update account &lt;span class=&quot;keyword&quot;&gt;set&lt;/span&gt; balance=balance+transferAmount &lt;span class=&quot;keyword&quot;&gt;where&lt;/span&gt; uid=B;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;(deductRet==&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    LogHelper.info(&lt;span class=&quot;string&quot;&gt;&quot;account B add &quot;&lt;/span&gt;+transferAmount+&lt;span class=&quot;string&quot;&gt;&quot; success.&quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; ErrorResult(&lt;span class=&quot;number&quot;&gt;300&lt;/span&gt;,&lt;span class=&quot;string&quot;&gt;&quot;账户增加余额失败.&quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//5.提交事务&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//6.如果遭遇数据库异常(SQLException)，回滚事务&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//7.返回处理结果&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;那在没有事务的情况下会发生什么呢？在步骤1中，同时有2个线程X、Y，线程X先执行查询，发现余额充足，可以扣款，还没有进行步骤2时，Y此时将款项先扣除了，导致X线程的步骤2失败。其他的，在执行的任一阶段，都有可能遭遇不可抗力因素，比如，执行完步骤2，还未执行步骤3时，适逢操作系统crash或断电、存储介质失败等情况，此时没有事务的一致性保证，在系统恢复时将无法回滚，导致数据不一致。&lt;/p&gt;
&lt;p&gt;Lost update：&lt;br&gt;两个事务都同时更新一行数据，但是第二个事务却中途失败退出，导致对数据的两个修改都失效了。&lt;/p&gt;
&lt;p&gt;Dirty Reads：&lt;br&gt;一个事务开始读取了某行数据，但是另外一个事务已经更新了此数据但没有能够及时提交。这是相当危险的，因为很可能所有的操作都被回滚。&lt;/p&gt;
&lt;p&gt;Non-repeatable Reads：&lt;br&gt;一个事务对同一行数据重复读取两次，但是却得到了不同的结果。&lt;/p&gt;
&lt;p&gt;Second lost updates problem：&lt;br&gt;无法重复读取的特例。有两个并发事务同时读取同一行数据，然后其中一个对它进行修改提交，而另一个也进行了修改提交。这就会造成第一次写操作失效。&lt;/p&gt;
&lt;p&gt;Phantom Reads：&lt;br&gt;事务在操作过程中进行两次查询，第二次查询的结果包含了第一次查询中未出现的数据（这里并不要求两次查询的SQL语句相同）。这是因为在两次查询过程中有另外一个事务插入数据造成的。&lt;/p&gt;
&lt;h4 id=&quot;原子性（Atomicity）&quot;&gt;&lt;a href=&quot;#原子性（Atomicity）&quot; class=&quot;headerlink&quot; title=&quot;原子性（Atomicity）&quot;&gt;&lt;/a&gt;原子性（Atomicity）&lt;/h4&gt;&lt;p&gt;不可拆分，组成事务的系列操作是一个整体，要么全执行，要么不执行，不允许部分执行。通过上面例子就是从 A 同学扣除钱和向 B 同学增加 100 是一起发生的，不可能出现扣除了 A 的钱，但没增加 B 的钱的情况。&lt;/p&gt;
&lt;h4 id=&quot;一致性（Consistency）&quot;&gt;&lt;a href=&quot;#一致性（Consistency）&quot; class=&quot;headerlink&quot; title=&quot;一致性（Consistency）&quot;&gt;&lt;/a&gt;一致性（Consistency）&lt;/h4&gt;&lt;p&gt;一致性指的是语义上的一致性，即业务逻辑层面的一致。在事务开始之前和事务结束以后，数据库的完整性和状态没有被破坏，而在事务执行阶段，一致性是会被破坏的。这个怎么理解呢？就是 A、B 两人在转账钱的总和是 2,000，转账后两人的总和也必须是 2,000。不会因为这次转账事务破坏这个状态。如果帐户A上的钱减少了，而帐户B上的钱却没有增加(如在执行步骤3时失败)，那么我们认为此时数据处于不一致的状态。&lt;/p&gt;
&lt;p&gt;在事务处理的ACID属性中，一致性是最基本的属性，其它的三个属性都为了保证一致性而存在的。&lt;/p&gt;
&lt;h4 id=&quot;隔离性（Isolation）&quot;&gt;&lt;a href=&quot;#隔离性（Isolation）&quot; class=&quot;headerlink&quot; title=&quot;隔离性（Isolation）&quot;&gt;&lt;/a&gt;隔离性（Isolation）&lt;/h4&gt;&lt;p&gt;多个事务在并发执行时，事务执行的中间状态是其他事务不可访问的。A 转出 100 但事务没有确认提交，这时候银行人员对其账号查询时，看到的应该还是 1,000，不是 900。&lt;/p&gt;
&lt;h4 id=&quot;持久性（Durability）&quot;&gt;&lt;a href=&quot;#持久性（Durability）&quot; class=&quot;headerlink&quot; title=&quot;持久性（Durability）&quot;&gt;&lt;/a&gt;持久性（Durability）&lt;/h4&gt;&lt;p&gt;事务一旦提交生效，其结果将永久保存，不受任何故障影响。A 转账一但完成，那么 A 就是 900，B 就是 1,100，这个结果将永远保存在银行的数据库中，直到他们下次交易事务的发生。&lt;/p&gt;
&lt;p&gt;redo log，undo log，WAL。&lt;/p&gt;
&lt;p&gt;MySQL数据库innodb的事务，是通过redo log（innodb log)，undo log，锁机制，来维护这个一致性的。&lt;/p&gt;
&lt;h3 id=&quot;逻辑事务-VS-物理事务&quot;&gt;&lt;a href=&quot;#逻辑事务-VS-物理事务&quot; class=&quot;headerlink&quot; title=&quot;逻辑事务 VS 物理事务&quot;&gt;&lt;/a&gt;逻辑事务 VS 物理事务&lt;/h3&gt;&lt;h3 id=&quot;编程式事务-VS-声明式事务&quot;&gt;&lt;a href=&quot;#编程式事务-VS-声明式事务&quot; class=&quot;headerlink&quot; title=&quot;编程式事务 VS 声明式事务&quot;&gt;&lt;/a&gt;编程式事务 VS 声明式事务&lt;/h3&gt;&lt;h3 id=&quot;事务隔离级别&quot;&gt;&lt;a href=&quot;#事务隔离级别&quot; class=&quot;headerlink&quot; title=&quot;事务隔离级别&quot;&gt;&lt;/a&gt;事务隔离级别&lt;/h3&gt;&lt;h4 id=&quot;默认隔离级别&quot;&gt;&lt;a href=&quot;#默认隔离级别&quot; class=&quot;headerlink&quot; title=&quot;默认隔离级别&quot;&gt;&lt;/a&gt;默认隔离级别&lt;/h4&gt;&lt;h5 id=&quot;不同ORM框架的默认隔离级别&quot;&gt;&lt;a href=&quot;#不同ORM框架的默认隔离级别&quot; class=&quot;headerlink&quot; title=&quot;不同ORM框架的默认隔离级别&quot;&gt;&lt;/a&gt;不同ORM框架的默认隔离级别&lt;/h5&gt;&lt;h5 id=&quot;不同DB-Proxy的默认隔离级别&quot;&gt;&lt;a href=&quot;#不同DB-Proxy的默认隔离级别&quot; class=&quot;headerlink&quot; title=&quot;不同DB Proxy的默认隔离级别&quot;&gt;&lt;/a&gt;不同DB Proxy的默认隔离级别&lt;/h5&gt;&lt;h5 id=&quot;不同RDBMS的默认隔离级别&quot;&gt;&lt;a href=&quot;#不同RDBMS的默认隔离级别&quot; class=&quot;headerlink&quot; title=&quot;不同RDBMS的默认隔离级别&quot;&gt;&lt;/a&gt;不同RDBMS的默认隔离级别&lt;/h5&gt;&lt;p&gt;不同存储引擎的默认隔离级别&lt;/p&gt;
&lt;h3 id=&quot;事务传播行为&quot;&gt;&lt;a href=&quot;#事务传播行为&quot; class=&quot;headerlink&quot; title=&quot;事务传播行为&quot;&gt;&lt;/a&gt;事务传播行为&lt;/h3&gt;&lt;h4 id=&quot;默认传播行为&quot;&gt;&lt;a href=&quot;#默认传播行为&quot; class=&quot;headerlink&quot; title=&quot;默认传播行为&quot;&gt;&lt;/a&gt;默认传播行为&lt;/h4&gt;&lt;h3 id=&quot;RDBMS如何权衡事务隔离与高并发读写？&quot;&gt;&lt;a href=&quot;#RDBMS如何权衡事务隔离与高并发读写？&quot; class=&quot;headerlink&quot; title=&quot;RDBMS如何权衡事务隔离与高并发读写？&quot;&gt;&lt;/a&gt;RDBMS如何权衡事务隔离与高并发读写？&lt;/h3&gt;&lt;h4 id=&quot;MVCC与Free-Lock&quot;&gt;&lt;a href=&quot;#MVCC与Free-Lock&quot; class=&quot;headerlink&quot; title=&quot;MVCC与Free Lock&quot;&gt;&lt;/a&gt;MVCC与Free Lock&lt;/h4&gt;&lt;p&gt;多线程环境下各种数据结构的实现有了很大的变化，每当我们更新某个数据的时候，我们都要考虑其它线程是否对其进行了修改。最简单的一种方法就是加锁，不过加锁会导致性能低下，而且可能阻塞其他线程。因此，我们引入了非阻塞(non-blocking)的算法 —— 通过CAS（Compare &amp;amp; Set，或是Compare &amp;amp; Swap）操作保证操作的原子性，同时我们还引入了 lock-free 的概念，它指的是一个线程出现问题（如阻塞，失败）但不影响其他线程（从总体看程序仍然是在运行的）&lt;/p&gt;
&lt;h5 id=&quot;共享锁&quot;&gt;&lt;a href=&quot;#共享锁&quot; class=&quot;headerlink&quot; title=&quot;共享锁&quot;&gt;&lt;/a&gt;共享锁&lt;/h5&gt;&lt;h5 id=&quot;排它锁&quot;&gt;&lt;a href=&quot;#排它锁&quot; class=&quot;headerlink&quot; title=&quot;排它锁&quot;&gt;&lt;/a&gt;排它锁&lt;/h5&gt;&lt;h5 id=&quot;间隙锁&quot;&gt;&lt;a href=&quot;#间隙锁&quot; class=&quot;headerlink&quot; title=&quot;间隙锁&quot;&gt;&lt;/a&gt;间隙锁&lt;/h5&gt;&lt;h3 id=&quot;在主从架构下RDBMS如何保证事务？&quot;&gt;&lt;a href=&quot;#在主从架构下RDBMS如何保证事务？&quot; class=&quot;headerlink&quot; title=&quot;在主从架构下RDBMS如何保证事务？&quot;&gt;&lt;/a&gt;在主从架构下RDBMS如何保证事务？&lt;/h3&gt;&lt;h3 id=&quot;在双主架构下RDBMS如何保证事务？&quot;&gt;&lt;a href=&quot;#在双主架构下RDBMS如何保证事务？&quot; class=&quot;headerlink&quot; title=&quot;在双主架构下RDBMS如何保证事务？&quot;&gt;&lt;/a&gt;在双主架构下RDBMS如何保证事务？&lt;/h3&gt;&lt;h3 id=&quot;双活数据中心的事务管理&quot;&gt;&lt;a href=&quot;#双活数据中心的事务管理&quot; class=&quot;headerlink&quot; title=&quot;双活数据中心的事务管理&quot;&gt;&lt;/a&gt;双活数据中心的事务管理&lt;/h3&gt;&lt;h2 id=&quot;分布式事务&quot;&gt;&lt;a href=&quot;#分布式事务&quot; class=&quot;headerlink&quot; title=&quot;分布式事务&quot;&gt;&lt;/a&gt;分布式事务&lt;/h2&gt;&lt;h3 id=&quot;2PC&quot;&gt;&lt;a href=&quot;#2PC&quot; class=&quot;headerlink&quot; title=&quot;2PC&quot;&gt;&lt;/a&gt;2PC&lt;/h3&gt;&lt;h3 id=&quot;3PC&quot;&gt;&lt;a href=&quot;#3PC&quot; class=&quot;headerlink&quot; title=&quot;3PC&quot;&gt;&lt;/a&gt;3PC&lt;/h3&gt;&lt;h3 id=&quot;拜占庭将军问题-两军问题&quot;&gt;&lt;a href=&quot;#拜占庭将军问题-两军问题&quot; class=&quot;headerlink&quot; title=&quot;拜占庭将军问题/两军问题&quot;&gt;&lt;/a&gt;拜占庭将军问题/两军问题&lt;/h3&gt;&lt;h3 id=&quot;事务解耦&quot;&gt;&lt;a href=&quot;#事务解耦&quot; class=&quot;headerlink&quot; title=&quot;事务解耦&quot;&gt;&lt;/a&gt;事务解耦&lt;/h3&gt;&lt;h3 id=&quot;事务补偿&quot;&gt;&lt;a href=&quot;#事务补偿&quot; class=&quot;headerlink&quot; title=&quot;事务补偿&quot;&gt;&lt;/a&gt;事务补偿&lt;/h3&gt;&lt;h3 id=&quot;事务回滚&quot;&gt;&lt;a href=&quot;#事务回滚&quot; class=&quot;headerlink&quot; title=&quot;事务回滚&quot;&gt;&lt;/a&gt;事务回滚&lt;/h3&gt;&lt;h3 id=&quot;最终资源一致性&quot;&gt;&lt;a href=&quot;#最终资源一致性&quot; class=&quot;headerlink&quot; title=&quot;最终资源一致性&quot;&gt;&lt;/a&gt;最终资源一致性&lt;/h3&gt;&lt;h3 id=&quot;与nosql&quot;&gt;&lt;a href=&quot;#与nosql&quot; class=&quot;headerlink&quot; title=&quot;与nosql&quot;&gt;&lt;/a&gt;与nosql&lt;/h3&gt;&lt;h4 id=&quot;MongoDB如何实现事务？&quot;&gt;&lt;a href=&quot;#MongoDB如何实现事务？&quot; class=&quot;headerlink&quot; title=&quot;MongoDB如何实现事务？&quot;&gt;&lt;/a&gt;MongoDB如何实现事务？&lt;/h4&gt;&lt;h5 id=&quot;表锁与行锁&quot;&gt;&lt;a href=&quot;#表锁与行锁&quot; class=&quot;headerlink&quot; title=&quot;表锁与行锁&quot;&gt;&lt;/a&gt;表锁与行锁&lt;/h5&gt;&lt;h4 id=&quot;Redis如何实现事务？&quot;&gt;&lt;a href=&quot;#Redis如何实现事务？&quot; class=&quot;headerlink&quot; title=&quot;Redis如何实现事务？&quot;&gt;&lt;/a&gt;Redis如何实现事务？&lt;/h4&gt;&lt;h5 id=&quot;串行化&quot;&gt;&lt;a href=&quot;#串行化&quot; class=&quot;headerlink&quot; title=&quot;串行化&quot;&gt;&lt;/a&gt;串行化&lt;/h5&gt;&lt;h6 id=&quot;Redis与MVCC实现Free-Lock&quot;&gt;&lt;a href=&quot;#Redis与MVCC实现Free-Lock&quot; class=&quot;headerlink&quot; title=&quot;Redis与MVCC实现Free Lock&quot;&gt;&lt;/a&gt;Redis与MVCC实现Free Lock&lt;/h6&gt;&lt;p&gt;HBase，couchBase，leveldb&lt;/p&gt;
&lt;h3 id=&quot;阿里DTS&quot;&gt;&lt;a href=&quot;#阿里DTS&quot; class=&quot;headerlink&quot; title=&quot;阿里DTS&quot;&gt;&lt;/a&gt;阿里DTS&lt;/h3&gt;&lt;h2 id=&quot;Reference&quot;&gt;&lt;a href=&quot;#Reference&quot; class=&quot;headerlink&quot; title=&quot;Reference&quot;&gt;&lt;/a&gt;Reference&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://zh.wikipedia.org/wiki/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BA%8B%E5%8A%A1&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;数据库事务-维基百科&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://zh.wikipedia.org/wiki/%E6%8B%9C%E5%8D%A0%E5%BA%AD%E5%B0%86%E5%86%9B%E9%97%AE%E9%A2%98&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;拜占庭将军问题&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</content>
    
    <summary type="html">
    
      以MySQL数据库系统为例，数据被按页（16K）存储在磁盘中，如何组织数据的存储格式，由存储引擎来定义。在数据被插入或修改时，为了提高TPS，规避磁盘写入缓慢的问题，MySQL会将新数据页缓冲到内存（Insert Buffer），达到一定时间，或者积累的数据达到一定量级后，会由Master Thread刷入磁盘，同时清空缓冲区（CheckPoint机制）。在数据需要读取时，先从磁盘按页读取，如果有配置缓冲池，这些取出的数据还会在内存中留一个副本（FIX），只要数据不进行修改，下次读取时就会冲缓冲池命中了，大大加快了访问速度。
    
    </summary>
    
      <category term="Summary" scheme="http://amao12580.github.io/categories/Summary/"/>
    
    
      <category term="Transaction" scheme="http://amao12580.github.io/tags/Transaction/"/>
    
      <category term="Spring" scheme="http://amao12580.github.io/tags/Spring/"/>
    
      <category term="MVCC" scheme="http://amao12580.github.io/tags/MVCC/"/>
    
      <category term="WAL" scheme="http://amao12580.github.io/tags/WAL/"/>
    
      <category term="RedoLog" scheme="http://amao12580.github.io/tags/RedoLog/"/>
    
      <category term="UndoLog" scheme="http://amao12580.github.io/tags/UndoLog/"/>
    
      <category term="RelayLog" scheme="http://amao12580.github.io/tags/RelayLog/"/>
    
  </entry>
  
  <entry>
    <title>分布式软件理论总结</title>
    <link href="http://amao12580.github.io/post/2016/05/Summary-of-distributed-theory/"/>
    <id>http://amao12580.github.io/post/2016/05/Summary-of-distributed-theory/</id>
    <published>2016-05-23T03:34:28.000Z</published>
    <updated>2016-06-03T02:31:04.879Z</updated>
    
    <content type="html">&lt;p&gt;&lt;img src=&quot;/images/loading.gif&quot; alt=&quot;&quot; class=&quot;hx_lazyimg&quot; data-original=&quot;http://amao12580.github.io/img/thinking.jpg&quot;&gt;&lt;/p&gt;
&lt;h1 id=&quot;软件系统的本质&quot;&gt;&lt;a href=&quot;#软件系统的本质&quot; class=&quot;headerlink&quot; title=&quot;软件系统的本质&quot;&gt;&lt;/a&gt;软件系统的本质&lt;/h1&gt;&lt;p&gt;软件是现实的抽象，讨论抽象的本质是困难的，让我们一起在现实中思考。小到一支笔，大到一部汽车，这些产品的出现，使我们在现实生活中得到了方便。这里说的方便，是指因为使用了这些产品，降低了成本，提高了效率。在没有笔的时代，想要记录信息需要结绳、岩画或篆刻，这是高成本的，效率也很低。同样的，没有汽车的时代，想要到达另一个城市，会因为恶劣天气而被迫中途搁置，相应的通行时间也会比现在长得多。进一步的思考，笔与汽车的共同点又在哪里呢？&lt;/p&gt;
&lt;p&gt;笔与汽车，这些产品是为了满足人们的各类生活需求而发明的。即，人们因为现实需要，而发明或改进了产品，产品是为了帮助人们更好的生活而存在。同样的，软件系统也是如此，人们出于远距离沟通交流需要，发明电话拨号系统；因为更随时随地的信息多样化交流，发明了各种互联网IM产品。&lt;/p&gt;
&lt;p&gt;软件系统是依托于人们现实需求而存在，用以辅助人们更好的生活，它是现实世界在虚拟世界的抽象。同样的软件系统也存在着兴衰淘汰，一款软件刚问世时，受欢迎程度总是处于低谷，存在现实世界对其接受适应的时间窗。突破时间窗，进而逐渐闻名天下，此时依托此软件又会催生出许多子软件链（如chromium的众多壳浏览器、SVN的众多客户端）。随着技术革新，软件产业也会更新换代，跟不上时代的软件系统会逐渐退出市场（如vista操作系统的短命）。但市场总是存在需要的，类似的软件在倒下后总会有后继者，如浏览器，这几乎在国内，每家互联网公司都想做或者已经在做。&lt;/p&gt;
&lt;h1 id=&quot;不良设计的局限性&quot;&gt;&lt;a href=&quot;#不良设计的局限性&quot; class=&quot;headerlink&quot; title=&quot;不良设计的局限性&quot;&gt;&lt;/a&gt;不良设计的局限性&lt;/h1&gt;&lt;p&gt;在软件系统的发展初期，适用面狭窄，功能单一、用户少、价值不够高，造成对软件系统研发的不重视，成本投入低。相应的，软件所带来的经济收益也是有限的。此时的软件系统往往谈不上架构，往往是一个软件系统承载了所有功能，单个功能模块没有边界，逻辑分散，而各个功能模块之间的耦合关系是散乱的。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/loading.gif&quot; alt=&quot;&quot; class=&quot;hx_lazyimg&quot; data-original=&quot;http://amao12580.github.io/img/chaos.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;在软件系统有机会成长起来后，带来了一定的经济收益。我们会思考软件系统的功能增多，更适应于用户（市场需要），或者考虑增强原有用户黏性，此时会对软件系统提出更多要求。而初期功能模块散乱的堆叠，对迫切需要的可扩展性带来了的麻烦，紧耦合的架构造成牵一发而动全身的问题，新功能的增加，往往意味着巨大地改造成本。勉强加上一些功能后，整个软件系统简直是乱作一团，就像是一堆红豆绿豆，这样的软件系统，我们称之为集中式软件系统。&lt;/p&gt;
&lt;p&gt;集中式的软件系统还对重构带来挑战，随着功能需求越来越频繁的提出，往往意味着需要更短的版本迭代周期。现有系统无法灵活扩展，意味着需要对整个软件系统进行重构，而等到软件散乱性膨胀到一定程度，重构几乎变成不可完成的任务，就算是系统初始负责人，也无法评估重构带来的风险与收益究竟谁更多？&lt;/p&gt;
&lt;h2 id=&quot;停不下来的运动员&quot;&gt;&lt;a href=&quot;#停不下来的运动员&quot; class=&quot;headerlink&quot; title=&quot;停不下来的运动员&quot;&gt;&lt;/a&gt;停不下来的运动员&lt;/h2&gt;&lt;p&gt;集中式的软件系统在濒危阶段，开发团队往往面临两难，团队任何人都知道急需重构，但因为没有决策权，最高决策领导也顾虑着市场利益，而不可能给出重构所需的资源(时间、人力、软硬件)。在愈发杂乱的系统上进行维护和新功能叠加，这让团队内的每个人都需要指数级的投入成本，往往还达不到市场需要的质量。&lt;/p&gt;
&lt;p&gt;就像田径400米接力比赛中，只能跑第一棒的运动员，本应在交棒后停下来休息，自我调整。而由于接手下一棒的运动员迟迟不能到位，运动员只能咬牙坚持跑第二棒，但迈出的每一步都越来越累，没法再像刚开始保持加速度。更令人担忧的是，此时裁判还吹响了冲刺哨，要求运动员进行冲锋。这样，运动员只有倒下了。相应的，软件系统到此时，开发团队成员会加速流失，新招进来的人也很难理解整套系统的协作，经常顾此失彼，从而导致最终的系统失败。&lt;/p&gt;
&lt;p&gt;这也就是为什么CTO必需对技术团队保持深入理解，同时还应有对产品、开发的最高决策权，以支持技术团队在适时进行系统级别的重构，让失去体力的软件系统下线休息，换上更适合的新软件系统上线，从而更好地满足公司的战略需求，这是非常有必要的。&lt;/p&gt;
&lt;h1 id=&quot;向敏捷开发过渡&quot;&gt;&lt;a href=&quot;#向敏捷开发过渡&quot; class=&quot;headerlink&quot; title=&quot;向敏捷开发过渡&quot;&gt;&lt;/a&gt;向敏捷开发过渡&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;/images/loading.gif&quot; alt=&quot;&quot; class=&quot;hx_lazyimg&quot; data-original=&quot;http://amao12580.github.io/img/building-blocks.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;在软件系统有机会从集中式软件模式，过渡到积木型的软件模式后。系统原有是100%的功能堆叠到一个系统，现在变成了多个积木，也就是软件子系统，每个积木只负责其中的部分功能，积木间的协作，从而拼装出完整的软件系统。&lt;/p&gt;
&lt;h2 id=&quot;快速交付&quot;&gt;&lt;a href=&quot;#快速交付&quot; class=&quot;headerlink&quot; title=&quot;快速交付&quot;&gt;&lt;/a&gt;快速交付&lt;/h2&gt;&lt;p&gt;集中式的软件往往灵活性低下，这体现在很多方面。&lt;/p&gt;
&lt;p&gt;1.设计的灵活性，想要以好的设计替换掉不再适应设计方案，会遭遇无法评估改造成本。&lt;/p&gt;
&lt;p&gt;2.构建的灵活性，软件功能过于集中，导致一个小的编译问题，都会影响整个软件的构建，就像走钢丝一样，必需每一步都完美无缺才能安全走到终点。&lt;/p&gt;
&lt;p&gt;3.测试的灵活性，测试任务因为功能互相紧耦合而变得繁重，无法评估已经做好的功能是否会受到影响。&lt;/p&gt;
&lt;p&gt;4.部署的灵活性，运维无法根据系统的流量特性来优化软硬件配置，如JVM调优，Load Balance等。&lt;/p&gt;
&lt;p&gt;5.修复的灵活性，这一点往往在集中式软件中是一个优势，在线上出现问题，只需要简单的分析少量的运行日志即可定位问题，这在积木性系统中是一个软肋。&lt;/p&gt;
&lt;p&gt;敏捷开发的主要优势就在于，合理的利用分治思想，将复杂的功能的系统模块化处理，拆分成由只有简单功能的子系统而拼凑出来的完整系统，每一个子系统可以交付到小团队来维护，甚至与有单独的运维人员来进行保障。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/loading.gif&quot; alt=&quot;&quot; class=&quot;hx_lazyimg&quot; data-original=&quot;http://amao12580.github.io/img/MircoService.png&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;可维护性&quot;&gt;&lt;a href=&quot;#可维护性&quot; class=&quot;headerlink&quot; title=&quot;可维护性&quot;&gt;&lt;/a&gt;可维护性&lt;/h2&gt;&lt;p&gt;这是一个巨大的转变，首当其冲的就是可维护性，只需要定义一套灵活的通信协议，子系统之间通过这套协议进行通讯，我们在对子系统内部的功能进行维护时，不必担忧其他子系统受到干扰。这也存在一个前提，能够封装在一个子系统的功能模块集合，必须是内聚型的，它们几乎很少对外层子系统产生耦合，或者通过统一的出口进行耦合关联。&lt;/p&gt;
&lt;h2 id=&quot;可扩展性&quot;&gt;&lt;a href=&quot;#可扩展性&quot; class=&quot;headerlink&quot; title=&quot;可扩展性&quot;&gt;&lt;/a&gt;可扩展性&lt;/h2&gt;&lt;p&gt;其次是软件的可扩展性，新功能的开发，只需要新加一个子系统，扩展通讯协议，就可以满足要求，这对团队内的任何一个人都是令人振奋的。&lt;/p&gt;
&lt;h2 id=&quot;隔离性&quot;&gt;&lt;a href=&quot;#隔离性&quot; class=&quot;headerlink&quot; title=&quot;隔离性&quot;&gt;&lt;/a&gt;隔离性&lt;/h2&gt;&lt;p&gt;积木型的软件构建，还给了我们保持专注的可能。现在我们可以为软件进行动静分离设计，以适应不同的最佳部署方式。可以按照系统流量特性，应用CQRS架构，提供更好的局部性能。进一步的还可以为强共用性的功能进行独立剥离出来，譬如单独的文件系统负责所有的文件服务，以在避免各个积木内部的重复造轮子，独立的服务还为以后的：可维护性、伸缩性带来了诸多方便。&lt;/p&gt;
&lt;h2 id=&quot;质量可控&quot;&gt;&lt;a href=&quot;#质量可控&quot; class=&quot;headerlink&quot; title=&quot;质量可控&quot;&gt;&lt;/a&gt;质量可控&lt;/h2&gt;&lt;p&gt;同时，软件的质量可以得到保证，测试部门可以明确的针对某个软件子系统进行测试，而不需要每次系统上线都进行整体测试，工作量的降低，在相等的时间内，有了更多的时间进行问题修复，这往往意味着质量的提高。&lt;/p&gt;
&lt;p&gt;积木型的软件，是对积木之间通讯协议的高要求，实际上，我们需要引入一整套消息通讯中间件来解决这个问题，在SOA和EDA架构中，最为关键的就是MQ协议的设计了。&lt;/p&gt;
&lt;p&gt;松耦合的模式还带来局部失败和最终一致性的问题，可能会给用户造成短时间迷惑，但不影响最终的数据状态统一，这在传统软件领域往往是不可接受的，但进入到互联网后，在系统层面往往需要进行权衡，是市场机遇重要？还是少部分的用户利益重要？这个问题需要每一个互联网人的思考，产品是不是要满足每一个人的要求呢？&lt;/p&gt;
&lt;h1 id=&quot;分布式系统的利与弊&quot;&gt;&lt;a href=&quot;#分布式系统的利与弊&quot; class=&quot;headerlink&quot; title=&quot;分布式系统的利与弊&quot;&gt;&lt;/a&gt;分布式系统的利与弊&lt;/h1&gt;&lt;h2 id=&quot;软件的构成&quot;&gt;&lt;a href=&quot;#软件的构成&quot; class=&quot;headerlink&quot; title=&quot;软件的构成&quot;&gt;&lt;/a&gt;软件的构成&lt;/h2&gt;&lt;p&gt;概括的讲，软件普遍是由三部分组成：接入、逻辑、存储。其中接入是可能没有的，比如定时任务型软件，由操作系统时间来触发，不需要外界的主动调度。而逻辑和存储，很难有软件是不需要的。而比如典型的在线社交服务，常规的构成可以分为：聊天服务、长连接服务、推送服务、好友信息服务、文件服务、推荐服务、广告服务。这些按业务功能相关性而划分的服务，没有哪一个可以脱离接入、逻辑和存储的。这些服务从本质上来说大部分都是OLTP(&lt;a href=&quot;http://blog.csdn.net/tianlesoftware/article/details/5794844&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Online Transaction Processing&lt;/a&gt;)，就是将现实生活中的沟通交流需求转移到了互联网进行。&lt;/p&gt;
&lt;h2 id=&quot;SOA-VS-EDA&quot;&gt;&lt;a href=&quot;#SOA-VS-EDA&quot; class=&quot;headerlink&quot; title=&quot;SOA VS EDA&quot;&gt;&lt;/a&gt;SOA VS EDA&lt;/h2&gt;&lt;h3 id=&quot;什么是SOA？&quot;&gt;&lt;a href=&quot;#什么是SOA？&quot; class=&quot;headerlink&quot; title=&quot;什么是SOA？&quot;&gt;&lt;/a&gt;什么是SOA？&lt;/h3&gt;&lt;h4 id=&quot;SOA-VS-Mirco-Service&quot;&gt;&lt;a href=&quot;#SOA-VS-Mirco-Service&quot; class=&quot;headerlink&quot; title=&quot;SOA VS Mirco Service&quot;&gt;&lt;/a&gt;SOA VS Mirco Service&lt;/h4&gt;&lt;h3 id=&quot;什么是EDA？&quot;&gt;&lt;a href=&quot;#什么是EDA？&quot; class=&quot;headerlink&quot; title=&quot;什么是EDA？&quot;&gt;&lt;/a&gt;什么是EDA？&lt;/h3&gt;&lt;h3 id=&quot;分场景使用&quot;&gt;&lt;a href=&quot;#分场景使用&quot; class=&quot;headerlink&quot; title=&quot;分场景使用&quot;&gt;&lt;/a&gt;分场景使用&lt;/h3&gt;&lt;h2 id=&quot;Design-for-failure&quot;&gt;&lt;a href=&quot;#Design-for-failure&quot; class=&quot;headerlink&quot; title=&quot;Design for failure&quot;&gt;&lt;/a&gt;Design for failure&lt;/h2&gt;&lt;h3 id=&quot;Fast-fail-VS-Retry&quot;&gt;&lt;a href=&quot;#Fast-fail-VS-Retry&quot; class=&quot;headerlink&quot; title=&quot;Fast fail VS Retry&quot;&gt;&lt;/a&gt;Fast fail VS Retry&lt;/h3&gt;&lt;h2 id=&quot;无状态&quot;&gt;&lt;a href=&quot;#无状态&quot; class=&quot;headerlink&quot; title=&quot;无状态&quot;&gt;&lt;/a&gt;无状态&lt;/h2&gt;&lt;h2 id=&quot;应用中心和任务中心&quot;&gt;&lt;a href=&quot;#应用中心和任务中心&quot; class=&quot;headerlink&quot; title=&quot;应用中心和任务中心&quot;&gt;&lt;/a&gt;应用中心和任务中心&lt;/h2&gt;&lt;p&gt;单点服务向多点服务的转变&lt;/p&gt;
&lt;p&gt;原因：&lt;br&gt;性能要求，多节点同时参与服务(按流量权重分发，负载均衡；按读写流量分发，读写分离)。&lt;br&gt;允许少部分节点失败，更可靠的运行。&lt;/p&gt;
&lt;p&gt;数据存储跨机分片，同时每片在多机存在复制集。计算资源无状态，本身就可以动态管理。便捷的扩容缩容(伸缩性)。&lt;/p&gt;
&lt;p&gt;因业务分拆，降低耦合粒度，降低系统扩展成本(可扩展性)，更高的可维护性。&lt;/p&gt;
&lt;p&gt;带来的问题。&lt;br&gt;系统内部改造，支持多节点转变。&lt;/p&gt;
&lt;p&gt;分布式事务，事务补偿。&lt;/p&gt;
&lt;p&gt;分布式存储&lt;/p&gt;
&lt;p&gt;分布式访问&lt;/p&gt;
&lt;p&gt;容忍最终一致性。&lt;/p&gt;
&lt;h1 id=&quot;Reference&quot;&gt;&lt;a href=&quot;#Reference&quot; class=&quot;headerlink&quot; title=&quot;Reference&quot;&gt;&lt;/a&gt;Reference&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&quot;https://blog.eood.cn/exception&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;互联网系统可靠性基础：正确的异常处理&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&quot;http://www.sczyh30.com/posts/Microservice/circuit-breaker-pattern/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;微服务设计：熔断器模式&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&quot;http://ju.outofmemory.cn/entry/195996&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;采用断路器设计模式来保护软件&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
</content>
    
    <summary type="html">
    
      集中式的软件系统在濒危阶段，开发团队往往面临两难，团队任何人都知道急需重构，但因为没有决策权，最高决策领导也顾虑着市场利益，而不可能给出重构所需的资源(时间、人力、软硬件)。在愈发杂乱的系统上进行维护和新功能叠加，这让团队内的每个人都需要指数级的投入成本，往往还达不到市场需要的质量。
    
    </summary>
    
      <category term="Summary" scheme="http://amao12580.github.io/categories/Summary/"/>
    
    
      <category term="Distributed" scheme="http://amao12580.github.io/tags/Distributed/"/>
    
  </entry>
  
  <entry>
    <title>软件重构经验总结</title>
    <link href="http://amao12580.github.io/post/2016/05/Software-refactoring-experience-summary/"/>
    <id>http://amao12580.github.io/post/2016/05/Software-refactoring-experience-summary/</id>
    <published>2016-05-17T07:24:39.000Z</published>
    <updated>2016-06-12T02:25:04.330Z</updated>
    
    <content type="html">&lt;p&gt;结合小旺项目的重构经历来分析&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;小旺项目：5月份重构方案&lt;/li&gt;
&lt;li&gt;小旺项目重构方案&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;先了解&quot;&gt;&lt;a href=&quot;#先了解&quot; class=&quot;headerlink&quot; title=&quot;先了解&quot;&gt;&lt;/a&gt;先了解&lt;/h1&gt;&lt;h2 id=&quot;了解中发现问题症结&quot;&gt;&lt;a href=&quot;#了解中发现问题症结&quot; class=&quot;headerlink&quot; title=&quot;了解中发现问题症结&quot;&gt;&lt;/a&gt;了解中发现问题症结&lt;/h2&gt;&lt;h2 id=&quot;了解中思考解决方案&quot;&gt;&lt;a href=&quot;#了解中思考解决方案&quot; class=&quot;headerlink&quot; title=&quot;了解中思考解决方案&quot;&gt;&lt;/a&gt;了解中思考解决方案&lt;/h2&gt;&lt;h2 id=&quot;选取合适的解决方案&quot;&gt;&lt;a href=&quot;#选取合适的解决方案&quot; class=&quot;headerlink&quot; title=&quot;选取合适的解决方案&quot;&gt;&lt;/a&gt;选取合适的解决方案&lt;/h2&gt;&lt;h2 id=&quot;保留可扩展性&quot;&gt;&lt;a href=&quot;#保留可扩展性&quot; class=&quot;headerlink&quot; title=&quot;保留可扩展性&quot;&gt;&lt;/a&gt;保留可扩展性&lt;/h2&gt;&lt;h2 id=&quot;保留可维护性&quot;&gt;&lt;a href=&quot;#保留可维护性&quot; class=&quot;headerlink&quot; title=&quot;保留可维护性&quot;&gt;&lt;/a&gt;保留可维护性&lt;/h2&gt;&lt;h1 id=&quot;再动手&quot;&gt;&lt;a href=&quot;#再动手&quot; class=&quot;headerlink&quot; title=&quot;再动手&quot;&gt;&lt;/a&gt;再动手&lt;/h1&gt;&lt;h2 id=&quot;重构方案的评审&quot;&gt;&lt;a href=&quot;#重构方案的评审&quot; class=&quot;headerlink&quot; title=&quot;重构方案的评审&quot;&gt;&lt;/a&gt;重构方案的评审&lt;/h2&gt;&lt;h2 id=&quot;理清方案的优势与不足&quot;&gt;&lt;a href=&quot;#理清方案的优势与不足&quot; class=&quot;headerlink&quot; title=&quot;理清方案的优势与不足&quot;&gt;&lt;/a&gt;理清方案的优势与不足&lt;/h2&gt;&lt;h2 id=&quot;资源预先到位&quot;&gt;&lt;a href=&quot;#资源预先到位&quot; class=&quot;headerlink&quot; title=&quot;资源预先到位&quot;&gt;&lt;/a&gt;资源预先到位&lt;/h2&gt;&lt;p&gt;包括重构的时间争取，参与人员配比，对其他软硬件资源、中间件的预研。&lt;/p&gt;
&lt;h2 id=&quot;重构前后的效果量化&quot;&gt;&lt;a href=&quot;#重构前后的效果量化&quot; class=&quot;headerlink&quot; title=&quot;重构前后的效果量化&quot;&gt;&lt;/a&gt;重构前后的效果量化&lt;/h2&gt;&lt;h2 id=&quot;充分的测试&quot;&gt;&lt;a href=&quot;#充分的测试&quot; class=&quot;headerlink&quot; title=&quot;充分的测试&quot;&gt;&lt;/a&gt;充分的测试&lt;/h2&gt;&lt;p&gt;基础方面的重构，需要充分的测试&lt;/p&gt;
&lt;h1 id=&quot;方案上线&quot;&gt;&lt;a href=&quot;#方案上线&quot; class=&quot;headerlink&quot; title=&quot;方案上线&quot;&gt;&lt;/a&gt;方案上线&lt;/h1&gt;</content>
    
    <summary type="html">
    
      重构更多的是对软件的可维护性和可扩展性进行提高，无法完成重构的软件，往往都逃不过被淘汰的命运。何时适宜进行重构，需要考量的因素有三个：成本、收益、风险。其中风险是最为重要的，如果系统不进行重构，在未来可能带来巨大的问题，如不能适应分布式部署。此时就有必要进行重构了，重构的同时还需要考虑完成重构需要的成本，包括时间成本、人力成本，团队往往时刻肩负着新功能的开发和旧功能的维护工作，如何在不多的时间和人力中挤出资源呢？
    
    </summary>
    
      <category term="Summary" scheme="http://amao12580.github.io/categories/Summary/"/>
    
    
      <category term="Experience" scheme="http://amao12580.github.io/tags/Experience/"/>
    
      <category term="Refactor" scheme="http://amao12580.github.io/tags/Refactor/"/>
    
  </entry>
  
  <entry>
    <title>如何更好地管理技术团队？</title>
    <link href="http://amao12580.github.io/post/2016/05/How-to-better-manage-the-technical-team/"/>
    <id>http://amao12580.github.io/post/2016/05/How-to-better-manage-the-technical-team/</id>
    <published>2016-05-11T10:38:31.000Z</published>
    <updated>2016-06-13T02:18:22.784Z</updated>
    
    <content type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;h2 id=&quot;PM与TL的区别&quot;&gt;&lt;a href=&quot;#PM与TL的区别&quot; class=&quot;headerlink&quot; title=&quot;PM与TL的区别&quot;&gt;&lt;/a&gt;PM与TL的区别&lt;/h2&gt;&lt;p&gt;其实一个Team Leader的职责与Project Manager相像，但Team Leader更着重于技术开发方面，通常一个大型项目都会有一两个开发团队由Team Leader带领，负责开发核心部分，而其它部分分派给不同开发小组或者分派给外包公司。在网上常看到几句话，贴切地形容了PM与TL的区别：“技术人员乐于被领导；但他们不喜欢被管理，不喜欢像牛一样被驱赶或指挥。管理者强迫人们服从他们的命令，而领导者则会带领他们一起工作。管理是客观的，没有个人感情因素，它假定被管理者没有思想和感受，被告知要做什么和该如何做。领导是引领、引导，它激励人们达成目标。领导力是带有强烈个人感情色彩的，它不是你能命令的，也不是你能测量评估和测试的。”&lt;/p&gt;
&lt;p&gt;TL对于团队内的member，必须在技术上能够进行胜任领导，他就像黑夜里的灯塔，引导和修正member前进的航向。因此TL也必需保持照亮团队，保持对member的充分了解，并在技术领域投入持续的学习热情，向团队成员传道，补齐短板，让大家的核心战斗力一起提高。&lt;/p&gt;
&lt;p&gt;无论是PM与TL，对业务与技术都要有深入的了解，只是PM更侧重于业务的管理，盈利的多少，风险的大小等等，而TL则侧重于项目的成本，开发的难度，软件的架构等技术方面的问题。在某些人眼中，技术与管理就像鱼与熊掌，不可兼得，但依在下看来，两者却是秤不离砣，密不可分。只要及时提升自己对技术与管理的认识，不断地向深一层发展，要从程序员提升到技术管理人员只是时间的问题。&lt;/p&gt;
&lt;p&gt;团队规模有限时，分工很可能没这么清晰，很多时候TL和PM是同一个人在兼任，角色的模糊，可能带来职责和权利的混乱，而且个人精力也有限，仅适合任务量较小时实行。&lt;/p&gt;
&lt;h2 id=&quot;技术管理与团队管理的区别&quot;&gt;&lt;a href=&quot;#技术管理与团队管理的区别&quot; class=&quot;headerlink&quot; title=&quot;技术管理与团队管理的区别&quot;&gt;&lt;/a&gt;技术管理与团队管理的区别&lt;/h2&gt;&lt;p&gt;技术团队与其它的团队的区别，可能在于技术人员的管理难度。一方面因为领域之间的差异性，譬如前端技术链与后端技术链的深与广，导致熟悉前端的同时，很难对后端保持足够的了解。另一方面在领域内的差异性，典型的是多年争论C语言与Java语言的优劣，忽视了技术都有局限性，脱离了使用需求的比较没有意义。如果技术人员比较狭隘，往往无法理解对方的差异性，从而造成不必要的争议。这一点在年轻的团队中，是很突出的问题，大家普遍经验欠缺，对上下游的技术无法做到足够认知，同时因为年轻而无法接受建议，行成内耗。&lt;/p&gt;
&lt;h3 id=&quot;凤栖梧桐&quot;&gt;&lt;a href=&quot;#凤栖梧桐&quot; class=&quot;headerlink&quot; title=&quot;凤栖梧桐&quot;&gt;&lt;/a&gt;凤栖梧桐&lt;/h3&gt;&lt;p&gt;技术团队管理需要划分为正切的两个方向：技术管理和团队管理。管理的目标是：提高协作时的执行力，执行效率，并约束进行规范执行。技术管理的目标是：保持并引导团队成员之间的技术协作一致性，如前端技术团队和后端技术团队。由技术负责人制定日常规范，推动规范的落地，以公有的强制约定来避免不必要的内耗。规范的含义是比较广泛的：设计规范、编码规范、安全规范、接口规范、部署规范。团队管理解决的问题是：如何持久降低团队之间或团队成员之间的合作成本？如产品团队和技术团队。除了leader的影响，往往需要合理的行政制度来作为基础。好的行政制度是公司最重要的部分，它就像生态系统中的土壤一样，有了好的土壤，才可能生长出好的团队。在互联网时代，站在巨人肩上而诞生的伟大产品屈指可数了，很难有产品在一开始就100%贴合市场，更多的需要快速试错，进行小步快走的方式进行迭代，而在持续打磨的过程中，产品也就自我完善，可以产生商业价值了。我们很难想象在二流的团队中如何诞生一流的产品呢？管理者也需要深思，在渴求的一流产品的同时，是否给予了一流产品诞生所需要的环境呢？&lt;/p&gt;
&lt;h3 id=&quot;能力与影响力同样重要&quot;&gt;&lt;a href=&quot;#能力与影响力同样重要&quot; class=&quot;headerlink&quot; title=&quot;能力与影响力同样重要&quot;&gt;&lt;/a&gt;能力与影响力同样重要&lt;/h3&gt;&lt;p&gt;从纯粹的技术工作者转向管理者难点在于是否具备了管理能力？对与团队内的成员，是否一致的认为在你的带领下可以得到更好的发展？可以是经济利益上的或职业发展上的。对于上层决策领导是否认为你可担此大任？而如果太过于沉迷技术，缺少与决策层的互动交流，导致上层无法相信你已经具备管理能力，或确实缺少部分能力(可能是软实力，语言沟通能力)，这在国外很常见，管理层大多是美国人或印度人，中国人由于文化上的本位差异，很难上升到管理层。&lt;/p&gt;
&lt;h1 id=&quot;技术管理&quot;&gt;&lt;a href=&quot;#技术管理&quot; class=&quot;headerlink&quot; title=&quot;技术管理&quot;&gt;&lt;/a&gt;技术管理&lt;/h1&gt;&lt;h2 id=&quot;设计规范&quot;&gt;&lt;a href=&quot;#设计规范&quot; class=&quot;headerlink&quot; title=&quot;设计规范&quot;&gt;&lt;/a&gt;设计规范&lt;/h2&gt;&lt;p&gt;如何在低复杂度、可维护性、可理解性之间进行平衡？需要在需求分析和系统设计时制定一些规范来约束，帮组我们低维护成本的延长软件生命周期。没有人可以保证业务在长远未来的走向，因此软件设计也只需要在可预见的范围内进行权衡考虑，超出范围的要交给升级版的设计来解决，这可能与传统思维不同。典型的，以系统容量进行设计，比如在电商系统中，按照统计数据分析预测在未来5年内，系统用户数会逐步增加到五千万，日订单量约在五百万左右。那我们在做系统设计时，就可以参照这些指标来做，只考虑5年内系统如何满足要求即可，但是请保留5年后设计进行升级的可能性，毕竟推倒重来的代价在系统愈发庞大后会让人无法接受。&lt;/p&gt;
&lt;h3 id=&quot;DRY&quot;&gt;&lt;a href=&quot;#DRY&quot; class=&quot;headerlink&quot; title=&quot;DRY&quot;&gt;&lt;/a&gt;DRY&lt;/h3&gt;&lt;p&gt;DRY(Don’t Repeat Yourself)的核心是面向可维护性，将性质重复的逻辑进行封装，抽象为一组对外调用的功能接口。&lt;/p&gt;
&lt;p&gt;DRY 是一个最简单的法则，也是最容易被理解的。但它也可能是最难被应用的（因为要做到这样，我们需要在泛型设计上做相当的努力，这并不是一件容易的事）。它意味着，当我们在两个或多个地方的时候发现一些相似的代码的时候，我们需要把他们的共性抽象出来形一个唯一的新方法，并且改变现有的地方的代码让他们以一些合适的参数调用这个新的方法。&lt;/p&gt;
&lt;h4 id=&quot;vs-WET&quot;&gt;&lt;a href=&quot;#vs-WET&quot; class=&quot;headerlink&quot; title=&quot;vs WET&quot;&gt;&lt;/a&gt;vs WET&lt;/h4&gt;&lt;p&gt;违反DRY原则的解决方案通常被称为WET，指代“write everything twice”。&lt;/p&gt;
&lt;h3 id=&quot;KISS&quot;&gt;&lt;a href=&quot;#KISS&quot; class=&quot;headerlink&quot; title=&quot;KISS&quot;&gt;&lt;/a&gt;KISS&lt;/h3&gt;&lt;p&gt;KISS(Keep It Simple, Stupid)原则，是指在设计当中应当注重简约的原则。不只是软件系统设计，甚至在用户体验，需求分析时也可以应用。产品设计中，堆叠功能是容易的，考虑如何做减法才能体现产品经理的水准。&lt;/p&gt;
&lt;p&gt;KISS原则在设计上可能最被推崇的，在家装设计，界面设计 ，操作设计上，复杂的东西越来越被众人所BS了，而简单的东西越来越被人所认可，比如这些UI的设计和我们中国网页（尤其是新浪的网页）者是负面的例子。“宜家”（IKEA）简约、效率的家居设计、生产思路；“微软”（Microsoft）“所见即所得”的理念；“谷歌”（Google)简约、直接的商业风格，无一例外的遵循了“kiss”原则，也正是“kiss”原则，成就了这些看似神奇的商业经典。而苹果公司的iPhone/iPad将这个原则实践到了极至。&lt;/p&gt;
&lt;p&gt;把一个事情搞复杂是一件简单的事，但要把一个复杂的事变简单，这是一件复杂的事。&lt;/p&gt;
&lt;h3 id=&quot;SOLID&quot;&gt;&lt;a href=&quot;#SOLID&quot; class=&quot;headerlink&quot; title=&quot;SOLID&quot;&gt;&lt;/a&gt;SOLID&lt;/h3&gt;&lt;p&gt;在程序设计领域， SOLID（单一功能、开闭原则、里氏替换、接口隔离以及依赖反转）是由罗伯特·C·马丁在21世纪早期引入的记忆术首字母缩略字，指代了面向对象编程和面向对象设计的五个基本原则。当这些原则被一起应用时，它们使得一个程序员开发一个容易进行软件维护和扩展的系统变得更加可能。SOLID所包含的原则是通过引发编程者进行软件源代码的代码重构进行软件的代码异味清扫，从而使得软件清晰可读以及可扩展时可以应用的指南。SOLID被典型的应用在测试驱动开发上，并且是敏捷开发以及自适应软件开发的基本原则的重要组成部分。&lt;/p&gt;
&lt;h3 id=&quot;YAGNI&quot;&gt;&lt;a href=&quot;#YAGNI&quot; class=&quot;headerlink&quot; title=&quot;YAGNI&quot;&gt;&lt;/a&gt;YAGNI&lt;/h3&gt;&lt;p&gt;YAGNI(You Ain’t Gonna Need It)：适可而止，只考虑和设计必须的功能，避免过度设计。只实现目前需要的功能，在以后您需要更多功能时，可以再进行添加。（You Ain’t Gonna Need It，YAGNI 原则）&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如无必要，勿增复杂性。&lt;/li&gt;
&lt;li&gt;软件开发先是一场沟通博弈。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;WebSphere的设计者就表示过他过度设计了这个产品。我们的程序员或是架构师在设计系统的时候，会考虑很多扩展性的东西，导致在架构与设计方面使用了大量折衷，最后导致项目失败。这是个令人感到讽刺的教训，因为本来希望尽可能延长项目的生命周期，结果反而缩短了生命周期。&lt;/p&gt;
&lt;h2 id=&quot;编码规范&quot;&gt;&lt;a href=&quot;#编码规范&quot; class=&quot;headerlink&quot; title=&quot;编码规范&quot;&gt;&lt;/a&gt;编码规范&lt;/h2&gt;&lt;h3 id=&quot;命名规范&quot;&gt;&lt;a href=&quot;#命名规范&quot; class=&quot;headerlink&quot; title=&quot;命名规范&quot;&gt;&lt;/a&gt;命名规范&lt;/h3&gt;&lt;p&gt;我们在编写任何程序之前，第一件事要做的就是命名。&lt;/p&gt;
&lt;p&gt;形如：需求文档名称，概要设计文档名称，接口文档名称，软件系统名称，功能模块名称，类名称，方法名称，参数名称…&lt;/p&gt;
&lt;p&gt;在认识陌生人时，第一次接触时互递名片，熟络后的沟通交流，都以名字来起始了。名字是否好记，影响会有多大呢？前公司有一同事丁某某，父母取名讨巧用了生僻字，导致每次登机之前，需要到机场值班经理盖章，白白浪费很多时间。而恰好他是销售经理，每周有2~3次的商务飞行。你在想他为什么不去换名字？想想30来岁的人生积累，需要多少成本改名字吧？想象不出来，问问自己更换使用5年以上的手机号码，成本是多大吧？&lt;/p&gt;
&lt;h4 id=&quot;重要性&quot;&gt;&lt;a href=&quot;#重要性&quot; class=&quot;headerlink&quot; title=&quot;重要性&quot;&gt;&lt;/a&gt;重要性&lt;/h4&gt;&lt;p&gt;命名规范竟如此重要，但大多数开发者的命名习惯往往没有你想象的那么好。除了上面提到的生僻字问题，还有很多人喜欢用拼音去命名类、函数，甚至是变量。我不知道这是英文词汇量的问题还是个人风格，但我个人非常不提倡这样做。如何优雅地为程序中的变量和函数命名？很简单，把你的变量名拎出来，问别人，你看到这个名字会想到什么，他说的和你想的一致，就用，否则就改。改到基本上不懂程序的人都能大概看懂你写的是什么，就优雅了。&lt;/p&gt;
&lt;p&gt;为什么重要？提高可维护性。不加约束的开发者写出来的代码，就像是大家临时拼凑出来的一桌菜，你上粤菜，他上川菜。虽然都好吃，但没有人全想吃，造成的局面是，爱吃粤菜的人总是夹粤菜，爱吃川菜的就不去吃粤菜了。在代码上来讲，各自的代码风格迥异，导致理解成本加大，你负责的代码需要修改时，就只有你能改了，团队其他人很难帮得上忙，如果修改工作量比较大，这岂不是把自己逼死吗？如果结合好的代码注释和设计文档，会不会理解成本下降呢？但就算是文档写得再详细，我们也要去读代码，所以文档主要是体现思路和反映需求和设计。在程序上，我们的命令应当和文档中的术语保持一致，而程序中的命名也应该是用和文档相同的风格，这样，我们可以少很多理解上的成本。好的代码在命名上是完全可读的，代码即文档，做到这点，可以极大的提高团队内协作效率。&lt;/p&gt;
&lt;p&gt;比较常见的有下面三种命名方式：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;驼峰(Camel)命名法:又称小驼峰命名法，除首单词外，其余所有单词的第一个字母大写。GetOrderList&lt;/li&gt;
&lt;li&gt;帕斯卡(Pascal)命名法:又称大驼峰命名法，所有单词的第一个字母大写。gtOrderList&lt;/li&gt;
&lt;li&gt;蛇形(Snake)命名法:单词与单词间用下划线做间隔，看起来就像是上下扭动的蛇。get_order_list&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;一般在命名函数和一般变量时，多使用小驼峰，命名常量和枚举变量时，使用大写的蛇形；命名类名多使用大驼峰，不建议使用蛇形命名。如在命名数据库表名时，最好使用小驼峰以一致性的对应到pojo。&lt;/p&gt;
&lt;p&gt;好的命名，还给代码审计、代码排错工作降低成本，在做code review时，如果缺失详细注释(在敏捷开发中很常见)，规范化的命名使大家的理解成本降低，从而让审计工作更容易完成。我们回过头来想，很多公司很难推动代码审计的落地，到底是什么原因在阻碍呢？还有在线上代码深层排错时，我们可以采用SystemTap火焰图技术来做，由于函数的名称通常会包含语义上的信息，在输出的图表中就可以轻易的按照函数名来推断问题所在，这是非常了不起的。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/loading.gif&quot; alt=&quot;&quot; class=&quot;hx_lazyimg&quot; data-original=&quot;http://amao12580.github.io/img/flameGraph.png&quot;&gt;&lt;/p&gt;
&lt;h4 id=&quot;如何做？&quot;&gt;&lt;a href=&quot;#如何做？&quot; class=&quot;headerlink&quot; title=&quot;如何做？&quot;&gt;&lt;/a&gt;如何做？&lt;/h4&gt;&lt;p&gt;具体的施行，可以参考：&lt;a href=&quot;http://blog.csdn.net/yzmyyff/article/details/45243261&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Google Java Style&lt;/a&gt;&lt;/p&gt;
&lt;h4 id=&quot;约定优于配置&quot;&gt;&lt;a href=&quot;#约定优于配置&quot; class=&quot;headerlink&quot; title=&quot;约定优于配置&quot;&gt;&lt;/a&gt;约定优于配置&lt;/h4&gt;&lt;p&gt;约定优于配置的目标是，团队内各成员参照约定的策略来进行开发，减少无意义的说明项，从而降低沟通成本。为降低持续学习成本和保证团队新成员快速融入，约定项不宜过多，且应该放到团队成员随意备查的地方(media wiki?)。&lt;/p&gt;
&lt;h5 id=&quot;过渡配置&quot;&gt;&lt;a href=&quot;#过渡配置&quot; class=&quot;headerlink&quot; title=&quot;过渡配置&quot;&gt;&lt;/a&gt;过渡配置&lt;/h5&gt;&lt;p&gt;Hibernate的早期版本中，将类及其属性映射到数据库上需要是在XML文件中的描述，其中大部分信息都应能够按照约定得到，如将类映射到同名的数据库表，将属性分别映射到表上的同名字段。这样的做法不仅繁琐易出错，而且可维护性低，后续的版本抛弃了XML配置文件，而是使用这些恰当的约定，对于不符合这些约定的情形，可以使用Java注解来说明。&lt;/p&gt;
&lt;p&gt;Spring由于其繁琐的配置，一度被人成为“配置地狱”，各种XML、Annotation配置，让人眼花缭乱，而且如果出错了也很难找出原因。Spring Boot项目就是为了解决配置繁琐的问题，最大化的实现convention over configuration(约定大于配置)。熟悉Ruby On Rails（ROR框架的程序员都知道，借助于ROR的脚手架工具只需简单的几步即可建立起一个Web应用程序。而Spring Boot就相当于Java平台上的ROR&lt;/p&gt;
&lt;p&gt;构建管理工具链中，有很多体现了这个原则的正确性，如从Ant到Maven的过渡，Grunt到Gulp的过渡。其他的在中间件产品中，redis和mongodb的配置文件也有体现，只需要很少的个性化配置就可以正常运行。&lt;/p&gt;
&lt;h5 id=&quot;改进&quot;&gt;&lt;a href=&quot;#改进&quot; class=&quot;headerlink&quot; title=&quot;改进&quot;&gt;&lt;/a&gt;改进&lt;/h5&gt;&lt;p&gt;约定优于配置（convention over configuration），也称作按约定编程，是一种软件设计范式，旨在减少软件开发人员需做决定的数量，获得简单的好处，而又不失灵活性。&lt;br&gt;本质是说，开发人员仅需规定应用中不符约定的部分。例如，如果模型中有个名为Sale的类，那么数据库中对应的表就会默认命名为sales。只有在偏离这一约定时，例如将该表命名为”products_sold”，才需写有关这个名字的配置。&lt;/p&gt;
&lt;h3 id=&quot;合理的设计&quot;&gt;&lt;a href=&quot;#合理的设计&quot; class=&quot;headerlink&quot; title=&quot;合理的设计&quot;&gt;&lt;/a&gt;合理的设计&lt;/h3&gt;&lt;p&gt;合理的设计，主要是面向软件可维护性、可扩展性提出，如果能兼顾性能和安全就更好了。设计是有成本的，如果软件的生命周期在预期内就不会太长，例如很多一次性的产品：企业内网IM系统，售卖后，几乎不再需要任何的维护。此时设计上就可以从简，没有必要为不会来临的维护去打基础，因此设计也是需要有一定的前瞻性。&lt;/p&gt;
&lt;h4 id=&quot;适时分层&quot;&gt;&lt;a href=&quot;#适时分层&quot; class=&quot;headerlink&quot; title=&quot;适时分层&quot;&gt;&lt;/a&gt;适时分层&lt;/h4&gt;&lt;p&gt;分层设计的好处主要是面向软件可维护性。合理的分层设计，往往将逻辑拆分为内聚的多层次，层之间的边界和职责是清晰的。例如典型的三层设计，展示层、逻辑层、数据层。带来的好处是显而易见的，对于数据层来说，只需要对逻辑层提供访问数据的接口，具体如何实现访问数据，是访问文件还是RDBMS、NoSQL，与逻辑层无关。相应的重构起来也是局部的，如更换搜索引擎：Solr –&amp;gt; Elastic Search，只需要重构数据层的具体实现即可，上层任何代码不需要改动，这对于高复杂度的软件无疑是友好的。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/loading.gif&quot; alt=&quot;&quot; class=&quot;hx_lazyimg&quot; data-original=&quot;http://amao12580.github.io/img/splitLayer.png&quot;&gt;&lt;/p&gt;
&lt;p&gt;那分层对与软件可扩展性的影响呢？带来了一定程度的坏影响，新加的业务逻辑功能，可能涉及到很多层的改造，而在Maven mutilModule模式下，很可能层之间的代码是隔离的。这意味着，新加功能的代码量会有增多，相应的整体构建需要分布进行后融合。反过来想，这不失为一个好的过滤器，帮助我们分辨开发者的技能是否满足团队要求？&lt;/p&gt;
&lt;p&gt;一般来说分层设计适用于大型软件的持续构建，它依靠团队内的其它高效率手段来弥补稍低的可扩展性。它对安全和性能，并没有什么影响。&lt;/p&gt;
&lt;h4 id=&quot;再谈过度设计&quot;&gt;&lt;a href=&quot;#再谈过度设计&quot; class=&quot;headerlink&quot; title=&quot;再谈过度设计&quot;&gt;&lt;/a&gt;再谈过度设计&lt;/h4&gt;&lt;p&gt;简单来说，过度设计就是进行了过多的面向未来的设计，进行了不必要的抽象封装，为系统增加了不必要的复杂度。&lt;br&gt;举个例子，你要做一个功能模块，但你考虑到到这个系统里还有几个未完成的模块和你要做的东西类似，所以你决定为此额外做一些抽象和封装，以便将来复用。然而到后来你开发那些相似的模块时你才发现，可能是由于抽象不足或抽象错误，你不得不重新修改之前的封装才能完成复用，导致最终成本实际上还不如不做；或者你发现复用的部分所降低的成本实际上还不如包装花费的成本。 这些都是最常见的过度设计的例子。&lt;br&gt;程序员在掌握了一些基本的设计能力之后，最常见也是最难克服的设计问题往往就是过度设计。上面的错误我相信大多数人都一而再，再而三的的犯过。&lt;/p&gt;
&lt;p&gt;与过度设计相对的就是设计不足。&lt;br&gt;虽然是两个相对的概念，但设计不足和过度设计绝大多数时候都是一起出现的。都是最常见的设计问题。设计不足不仅常见于新手，老手也常犯。甚至我还见过有一类老程序员在经历过多次过度设计的打击之后，转向另一个极端，否定抽象封装的作用，走上“反设计”的道路。&lt;/p&gt;
&lt;p&gt;过度设计和设计不足的平衡问题没有很好的解决办法，只有依靠经验的积累和不断的总结思考。如何把握这个度是最能考验程序员的经验和价值的问题之一。&lt;/p&gt;
&lt;p&gt;我所尝试过的软件方法中，有一种方法的思维方式对于解决这个问题帮助最大，就是TDD（测试驱动开发），这里简单说下为什么TDD能解决这个问题：&lt;br&gt;TDD的一个核心思想是小步增量，不断重构。具体说来就是TDD有两个状态（常见的说法是两顶帽子）：&lt;br&gt;状态A：用test case描绘需求，并使用最简单的方式满足这个test case。注意要用最简单的方式满足这个需求，不能为任何test case之外的需求做任何设计。 test case通过之后进入状态B；&lt;br&gt;状态B：重构代码，让现有的代码在尽量保持简单性的同时足够优雅清晰。注意此时你只能对现有的实现代码进行重构，不能增加任何新的功能和test case。&lt;br&gt;整个TDD的过程就是在这两个状态间不断转换的过程。在状态A增加功能，在状态B优化设计。&lt;/p&gt;
&lt;p&gt;TDD的这种思维方式走的稍微极端一点。它直接排斥任何对未来的设计，转而以优雅简洁的设计和test case来为未来需求的重构降低成本。 可以说严格遵循TDD做出来的设计必然在过度设计和设计不足方面都不会有太大的问题。&lt;/p&gt;
&lt;p&gt;我严重推荐TDD。不管你最终会不会接受TDD这种开发方式，它独特的思维方式都必然会给你的设计观念带来很大影响。&lt;/p&gt;
&lt;p&gt;过度设计的典型案例：&lt;a href=&quot;http://coolshell.cn/articles/3005.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;代码重构的一个示例&lt;/a&gt;&lt;/p&gt;
&lt;h4 id=&quot;模块化设计&quot;&gt;&lt;a href=&quot;#模块化设计&quot; class=&quot;headerlink&quot; title=&quot;模块化设计&quot;&gt;&lt;/a&gt;模块化设计&lt;/h4&gt;&lt;p&gt;模块化设计在重构时，可以将影响降到最低。达到低风险、低成本。它符合CCP原则（Common Closure Principle（CCP）– 共同封闭原则）。它对系统快速构建是一个阻碍，要求将可预见的性质相同代码，内聚到一个模块中。&lt;/p&gt;
&lt;p&gt;例如读取和更新配置文件的功能，在软件中很多逻辑中需要调用。例如：读取定时任务的触发条件、读取接口调用频次限制。无论是从XML或JSON甚至在DB中读取，其实逻辑差别甚少，无非是：链接配置源、读取所需参数、解析正确性，返回并应用。如果重复这样的代码，将给我们带来麻烦，多类配置项产生依赖关系，读取和更新的交织将变得非常复杂。采用模块化设计，也是DRY原则的体现，对同性质的代码进行内聚为一个模块，对外部调用提供多个组合接口即可。&lt;/p&gt;
&lt;h3 id=&quot;前轻后重&quot;&gt;&lt;a href=&quot;#前轻后重&quot; class=&quot;headerlink&quot; title=&quot;前轻后重&quot;&gt;&lt;/a&gt;前轻后重&lt;/h3&gt;&lt;p&gt;系统之间的调用链，前置系统轻逻辑。&lt;/p&gt;
&lt;h4 id=&quot;上轻下重，核心逻辑内敛&quot;&gt;&lt;a href=&quot;#上轻下重，核心逻辑内敛&quot; class=&quot;headerlink&quot; title=&quot;上轻下重，核心逻辑内敛&quot;&gt;&lt;/a&gt;上轻下重，核心逻辑内敛&lt;/h4&gt;&lt;p&gt;模块之间的调用链，上层模块轻逻辑&lt;/p&gt;
&lt;h3 id=&quot;基础优先&quot;&gt;&lt;a href=&quot;#基础优先&quot; class=&quot;headerlink&quot; title=&quot;基础优先&quot;&gt;&lt;/a&gt;基础优先&lt;/h3&gt;&lt;p&gt;在构建软件时，保持基础组件优先稳定下来，定义好对外接口，并保留可扩展性。&lt;br&gt;例如安全性设计，在后期加比在前期加的成本高很多。&lt;/p&gt;
&lt;h3 id=&quot;最小冗余&quot;&gt;&lt;a href=&quot;#最小冗余&quot; class=&quot;headerlink&quot; title=&quot;最小冗余&quot;&gt;&lt;/a&gt;最小冗余&lt;/h3&gt;&lt;h4 id=&quot;代码保持最少行数&quot;&gt;&lt;a href=&quot;#代码保持最少行数&quot; class=&quot;headerlink&quot; title=&quot;代码保持最少行数&quot;&gt;&lt;/a&gt;代码保持最少行数&lt;/h4&gt;&lt;p&gt;1.少一行代码，就少了一个潜在的bug&lt;/p&gt;
&lt;p&gt;2.行数少了，往往意味着重用性高了&lt;/p&gt;
&lt;p&gt;3.不要过度牺牲可读性&lt;/p&gt;
&lt;h3 id=&quot;保持简单&quot;&gt;&lt;a href=&quot;#保持简单&quot; class=&quot;headerlink&quot; title=&quot;保持简单&quot;&gt;&lt;/a&gt;保持简单&lt;/h3&gt;&lt;h4 id=&quot;简单意味着快速&quot;&gt;&lt;a href=&quot;#简单意味着快速&quot; class=&quot;headerlink&quot; title=&quot;简单意味着快速&quot;&gt;&lt;/a&gt;简单意味着快速&lt;/h4&gt;&lt;h4 id=&quot;简单意味着灵活&quot;&gt;&lt;a href=&quot;#简单意味着灵活&quot; class=&quot;headerlink&quot; title=&quot;简单意味着灵活&quot;&gt;&lt;/a&gt;简单意味着灵活&lt;/h4&gt;&lt;h4 id=&quot;简单意味着易扩展&quot;&gt;&lt;a href=&quot;#简单意味着易扩展&quot; class=&quot;headerlink&quot; title=&quot;简单意味着易扩展&quot;&gt;&lt;/a&gt;简单意味着易扩展&lt;/h4&gt;&lt;h4 id=&quot;简单意味着易重构&quot;&gt;&lt;a href=&quot;#简单意味着易重构&quot; class=&quot;headerlink&quot; title=&quot;简单意味着易重构&quot;&gt;&lt;/a&gt;简单意味着易重构&lt;/h4&gt;&lt;h3 id=&quot;Fast-fail&quot;&gt;&lt;a href=&quot;#Fast-fail&quot; class=&quot;headerlink&quot; title=&quot;Fast fail&quot;&gt;&lt;/a&gt;Fast fail&lt;/h3&gt;&lt;h3 id=&quot;代码即文档&quot;&gt;&lt;a href=&quot;#代码即文档&quot; class=&quot;headerlink&quot; title=&quot;代码即文档&quot;&gt;&lt;/a&gt;代码即文档&lt;/h3&gt;&lt;h4 id=&quot;合理的注释&quot;&gt;&lt;a href=&quot;#合理的注释&quot; class=&quot;headerlink&quot; title=&quot;合理的注释&quot;&gt;&lt;/a&gt;合理的注释&lt;/h4&gt;&lt;h3 id=&quot;关键业务设计宣讲&quot;&gt;&lt;a href=&quot;#关键业务设计宣讲&quot; class=&quot;headerlink&quot; title=&quot;关键业务设计宣讲&quot;&gt;&lt;/a&gt;关键业务设计宣讲&lt;/h3&gt;&lt;h4 id=&quot;保持一致的看法&quot;&gt;&lt;a href=&quot;#保持一致的看法&quot; class=&quot;headerlink&quot; title=&quot;保持一致的看法&quot;&gt;&lt;/a&gt;保持一致的看法&lt;/h4&gt;&lt;h3 id=&quot;小步快走&quot;&gt;&lt;a href=&quot;#小步快走&quot; class=&quot;headerlink&quot; title=&quot;小步快走&quot;&gt;&lt;/a&gt;小步快走&lt;/h3&gt;&lt;h4 id=&quot;意味着版本迭代快速&quot;&gt;&lt;a href=&quot;#意味着版本迭代快速&quot; class=&quot;headerlink&quot; title=&quot;意味着版本迭代快速&quot;&gt;&lt;/a&gt;意味着版本迭代快速&lt;/h4&gt;&lt;h4 id=&quot;意味着版本迭代稳定&quot;&gt;&lt;a href=&quot;#意味着版本迭代稳定&quot; class=&quot;headerlink&quot; title=&quot;意味着版本迭代稳定&quot;&gt;&lt;/a&gt;意味着版本迭代稳定&lt;/h4&gt;&lt;h4 id=&quot;意味着部署回滚成本低&quot;&gt;&lt;a href=&quot;#意味着部署回滚成本低&quot; class=&quot;headerlink&quot; title=&quot;意味着部署回滚成本低&quot;&gt;&lt;/a&gt;意味着部署回滚成本低&lt;/h4&gt;&lt;h2 id=&quot;重构与优化&quot;&gt;&lt;a href=&quot;#重构与优化&quot; class=&quot;headerlink&quot; title=&quot;重构与优化&quot;&gt;&lt;/a&gt;重构与优化&lt;/h2&gt;&lt;h3 id=&quot;紧急优先&quot;&gt;&lt;a href=&quot;#紧急优先&quot; class=&quot;headerlink&quot; title=&quot;紧急优先&quot;&gt;&lt;/a&gt;紧急优先&lt;/h3&gt;&lt;p&gt;优先对紧急需要改进的部分进行重构&lt;/p&gt;
&lt;h3 id=&quot;计划性的重构&quot;&gt;&lt;a href=&quot;#计划性的重构&quot; class=&quot;headerlink&quot; title=&quot;计划性的重构&quot;&gt;&lt;/a&gt;计划性的重构&lt;/h3&gt;&lt;p&gt;在敏捷开发时，往往时间不够，有些模块只能以非优雅的方式构建。但是需要在这些模块加上TODO以免重构时遗忘。&lt;/p&gt;
&lt;h3 id=&quot;时机&quot;&gt;&lt;a href=&quot;#时机&quot; class=&quot;headerlink&quot; title=&quot;时机&quot;&gt;&lt;/a&gt;时机&lt;/h3&gt;&lt;p&gt;团队一致认为模块维护成本高昂时，果断重构。&lt;/p&gt;
&lt;h3 id=&quot;基于成本的优化&quot;&gt;&lt;a href=&quot;#基于成本的优化&quot; class=&quot;headerlink&quot; title=&quot;基于成本的优化&quot;&gt;&lt;/a&gt;基于成本的优化&lt;/h3&gt;&lt;p&gt;CBO(Cost base optimize)&lt;/p&gt;
&lt;p&gt;引用数据库查询分析计划来说明：&lt;a href=&quot;http://blog.jobbole.com/100349&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;如果有人问你数据库的原理，叫他看这篇文章#查询优化器&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;数据支撑&quot;&gt;&lt;a href=&quot;#数据支撑&quot; class=&quot;headerlink&quot; title=&quot;数据支撑&quot;&gt;&lt;/a&gt;数据支撑&lt;/h3&gt;&lt;p&gt;给出重构前后的成本与收益报告&lt;/p&gt;
&lt;h3 id=&quot;持续性&quot;&gt;&lt;a href=&quot;#持续性&quot; class=&quot;headerlink&quot; title=&quot;持续性&quot;&gt;&lt;/a&gt;持续性&lt;/h3&gt;&lt;p&gt;在时间不够或时机不成熟时，分阶段的进行&lt;/p&gt;
&lt;h2 id=&quot;技术选型&quot;&gt;&lt;a href=&quot;#技术选型&quot; class=&quot;headerlink&quot; title=&quot;技术选型&quot;&gt;&lt;/a&gt;技术选型&lt;/h2&gt;&lt;h3 id=&quot;开源优先&quot;&gt;&lt;a href=&quot;#开源优先&quot; class=&quot;headerlink&quot; title=&quot;开源优先&quot;&gt;&lt;/a&gt;开源优先&lt;/h3&gt;&lt;p&gt;Facebook在推广MyRock持有非常开放的态度，所有的源码开发都是在外部的github上进行的，社区的大量使用可以带来软件的进一步成熟，进而反哺其本身的业务。&lt;/p&gt;
&lt;p&gt;开源意味着安全，源码的公开维护，使得热门源码的安全漏洞被很大几率发现，进而修复。&lt;/p&gt;
&lt;p&gt;开源不意味着任何人都可以修改代码，事实上这将带来隐藏bug问题。在github上，你可以对public权限的代码进行PR（pull request），而是否采纳你的PR，由维护团队来决定。&lt;/p&gt;
&lt;h3 id=&quot;稳定优先&quot;&gt;&lt;a href=&quot;#稳定优先&quot; class=&quot;headerlink&quot; title=&quot;稳定优先&quot;&gt;&lt;/a&gt;稳定优先&lt;/h3&gt;&lt;h3 id=&quot;掌控度高优先&quot;&gt;&lt;a href=&quot;#掌控度高优先&quot; class=&quot;headerlink&quot; title=&quot;掌控度高优先&quot;&gt;&lt;/a&gt;掌控度高优先&lt;/h3&gt;&lt;h3 id=&quot;保留备选项&quot;&gt;&lt;a href=&quot;#保留备选项&quot; class=&quot;headerlink&quot; title=&quot;保留备选项&quot;&gt;&lt;/a&gt;保留备选项&lt;/h3&gt;&lt;h3 id=&quot;只有合适的技术，没有最好的技术。&quot;&gt;&lt;a href=&quot;#只有合适的技术，没有最好的技术。&quot; class=&quot;headerlink&quot; title=&quot;只有合适的技术，没有最好的技术。&quot;&gt;&lt;/a&gt;只有合适的技术，没有最好的技术。&lt;/h3&gt;&lt;h3 id=&quot;避免一招鲜吃遍天&quot;&gt;&lt;a href=&quot;#避免一招鲜吃遍天&quot; class=&quot;headerlink&quot; title=&quot;避免一招鲜吃遍天&quot;&gt;&lt;/a&gt;避免一招鲜吃遍天&lt;/h3&gt;&lt;p&gt;手里有锤子，看到什么都觉得像钉子&lt;/p&gt;
&lt;h3 id=&quot;技术升级&quot;&gt;&lt;a href=&quot;#技术升级&quot; class=&quot;headerlink&quot; title=&quot;技术升级&quot;&gt;&lt;/a&gt;技术升级&lt;/h3&gt;&lt;p&gt;系统容量与性能指标的要求，在业务发展的各个阶段是不固定的，技术需要保留一定前瞻性，不做被动跟随。&lt;/p&gt;
&lt;h2 id=&quot;接口规范&quot;&gt;&lt;a href=&quot;#接口规范&quot; class=&quot;headerlink&quot; title=&quot;接口规范&quot;&gt;&lt;/a&gt;接口规范&lt;/h2&gt;&lt;h3 id=&quot;内部接口&quot;&gt;&lt;a href=&quot;#内部接口&quot; class=&quot;headerlink&quot; title=&quot;内部接口&quot;&gt;&lt;/a&gt;内部接口&lt;/h3&gt;&lt;h4 id=&quot;版本控制&quot;&gt;&lt;a href=&quot;#版本控制&quot; class=&quot;headerlink&quot; title=&quot;版本控制&quot;&gt;&lt;/a&gt;版本控制&lt;/h4&gt;&lt;h4 id=&quot;访问控制&quot;&gt;&lt;a href=&quot;#访问控制&quot; class=&quot;headerlink&quot; title=&quot;访问控制&quot;&gt;&lt;/a&gt;访问控制&lt;/h4&gt;&lt;p&gt;访问权限的验证&lt;br&gt;访问频率&lt;/p&gt;
&lt;h4 id=&quot;流量控制&quot;&gt;&lt;a href=&quot;#流量控制&quot; class=&quot;headerlink&quot; title=&quot;流量控制&quot;&gt;&lt;/a&gt;流量控制&lt;/h4&gt;&lt;p&gt;拒绝恶意访问&lt;/p&gt;
&lt;p&gt;暴力破解&lt;/p&gt;
&lt;h4 id=&quot;审查与监控&quot;&gt;&lt;a href=&quot;#审查与监控&quot; class=&quot;headerlink&quot; title=&quot;审查与监控&quot;&gt;&lt;/a&gt;审查与监控&lt;/h4&gt;&lt;h4 id=&quot;灰度发布&quot;&gt;&lt;a href=&quot;#灰度发布&quot; class=&quot;headerlink&quot; title=&quot;灰度发布&quot;&gt;&lt;/a&gt;灰度发布&lt;/h4&gt;&lt;h4 id=&quot;无状态&quot;&gt;&lt;a href=&quot;#无状态&quot; class=&quot;headerlink&quot; title=&quot;无状态&quot;&gt;&lt;/a&gt;无状态&lt;/h4&gt;&lt;h4 id=&quot;原子化&quot;&gt;&lt;a href=&quot;#原子化&quot; class=&quot;headerlink&quot; title=&quot;原子化&quot;&gt;&lt;/a&gt;原子化&lt;/h4&gt;&lt;h4 id=&quot;CQRS&quot;&gt;&lt;a href=&quot;#CQRS&quot; class=&quot;headerlink&quot; title=&quot;CQRS&quot;&gt;&lt;/a&gt;CQRS&lt;/h4&gt;&lt;p&gt;命令查询职责分离模式，读不强依赖写。&lt;/p&gt;
&lt;h3 id=&quot;APP&quot;&gt;&lt;a href=&quot;#APP&quot; class=&quot;headerlink&quot; title=&quot;APP&quot;&gt;&lt;/a&gt;APP&lt;/h3&gt;&lt;h4 id=&quot;远程控制权&quot;&gt;&lt;a href=&quot;#远程控制权&quot; class=&quot;headerlink&quot; title=&quot;远程控制权&quot;&gt;&lt;/a&gt;远程控制权&lt;/h4&gt;&lt;h4 id=&quot;展示为主&quot;&gt;&lt;a href=&quot;#展示为主&quot; class=&quot;headerlink&quot; title=&quot;展示为主&quot;&gt;&lt;/a&gt;展示为主&lt;/h4&gt;&lt;h4 id=&quot;少的逻辑&quot;&gt;&lt;a href=&quot;#少的逻辑&quot; class=&quot;headerlink&quot; title=&quot;少的逻辑&quot;&gt;&lt;/a&gt;少的逻辑&lt;/h4&gt;&lt;h4 id=&quot;适度安全&quot;&gt;&lt;a href=&quot;#适度安全&quot; class=&quot;headerlink&quot; title=&quot;适度安全&quot;&gt;&lt;/a&gt;适度安全&lt;/h4&gt;&lt;h3 id=&quot;外部接口&quot;&gt;&lt;a href=&quot;#外部接口&quot; class=&quot;headerlink&quot; title=&quot;外部接口&quot;&gt;&lt;/a&gt;外部接口&lt;/h3&gt;&lt;h4 id=&quot;合理调用&quot;&gt;&lt;a href=&quot;#合理调用&quot; class=&quot;headerlink&quot; title=&quot;合理调用&quot;&gt;&lt;/a&gt;合理调用&lt;/h4&gt;&lt;p&gt;同步VS异步&lt;br&gt;批量VS单个  批量：局部失败&lt;/p&gt;
&lt;h4 id=&quot;保持怀疑&quot;&gt;&lt;a href=&quot;#保持怀疑&quot; class=&quot;headerlink&quot; title=&quot;保持怀疑&quot;&gt;&lt;/a&gt;保持怀疑&lt;/h4&gt;&lt;h5 id=&quot;兜底方案&quot;&gt;&lt;a href=&quot;#兜底方案&quot; class=&quot;headerlink&quot; title=&quot;兜底方案&quot;&gt;&lt;/a&gt;兜底方案&lt;/h5&gt;&lt;p&gt;如果有可能，在外部接口调用失败时，读取本地上一次调用成功的缓存。例如：加载和更新广告，CDN访问失败进行回源。&lt;/p&gt;
&lt;p&gt;进行兜底时，注意将失败的信息进行记录以便告警&lt;/p&gt;
&lt;h2 id=&quot;部署规范&quot;&gt;&lt;a href=&quot;#部署规范&quot; class=&quot;headerlink&quot; title=&quot;部署规范&quot;&gt;&lt;/a&gt;部署规范&lt;/h2&gt;&lt;h3 id=&quot;监控&quot;&gt;&lt;a href=&quot;#监控&quot; class=&quot;headerlink&quot; title=&quot;监控&quot;&gt;&lt;/a&gt;监控&lt;/h3&gt;&lt;h3 id=&quot;降低升级时间窗&quot;&gt;&lt;a href=&quot;#降低升级时间窗&quot; class=&quot;headerlink&quot; title=&quot;降低升级时间窗&quot;&gt;&lt;/a&gt;降低升级时间窗&lt;/h3&gt;&lt;h3 id=&quot;没有人需要等待&quot;&gt;&lt;a href=&quot;#没有人需要等待&quot; class=&quot;headerlink&quot; title=&quot;没有人需要等待&quot;&gt;&lt;/a&gt;没有人需要等待&lt;/h3&gt;&lt;p&gt;正式发布后，对于任何用户都是公平使用的。不需要牺牲部分用户利益。&lt;br&gt;常见于缓存autowarm时需要阻塞第一批到达的用户。&lt;/p&gt;
&lt;h3 id=&quot;提前消除隐患&quot;&gt;&lt;a href=&quot;#提前消除隐患&quot; class=&quot;headerlink&quot; title=&quot;提前消除隐患&quot;&gt;&lt;/a&gt;提前消除隐患&lt;/h3&gt;&lt;h1 id=&quot;团队管理&quot;&gt;&lt;a href=&quot;#团队管理&quot; class=&quot;headerlink&quot; title=&quot;团队管理&quot;&gt;&lt;/a&gt;团队管理&lt;/h1&gt;&lt;p&gt;识人、用人、管人、留人。&lt;/p&gt;
&lt;h2 id=&quot;精细化管理&quot;&gt;&lt;a href=&quot;#精细化管理&quot; class=&quot;headerlink&quot; title=&quot;精细化管理&quot;&gt;&lt;/a&gt;精细化管理&lt;/h2&gt;&lt;h2 id=&quot;keep-watch&quot;&gt;&lt;a href=&quot;#keep-watch&quot; class=&quot;headerlink&quot; title=&quot;keep watch&quot;&gt;&lt;/a&gt;keep watch&lt;/h2&gt;&lt;p&gt;工作与心理的交流分享&lt;/p&gt;
&lt;h2 id=&quot;保持信任&quot;&gt;&lt;a href=&quot;#保持信任&quot; class=&quot;headerlink&quot; title=&quot;保持信任&quot;&gt;&lt;/a&gt;保持信任&lt;/h2&gt;&lt;h2 id=&quot;保持怀疑-1&quot;&gt;&lt;a href=&quot;#保持怀疑-1&quot; class=&quot;headerlink&quot; title=&quot;保持怀疑&quot;&gt;&lt;/a&gt;保持怀疑&lt;/h2&gt;&lt;h2 id=&quot;持续考评&quot;&gt;&lt;a href=&quot;#持续考评&quot; class=&quot;headerlink&quot; title=&quot;持续考评&quot;&gt;&lt;/a&gt;持续考评&lt;/h2&gt;&lt;h3 id=&quot;KPI-VS-OKR&quot;&gt;&lt;a href=&quot;#KPI-VS-OKR&quot; class=&quot;headerlink&quot; title=&quot;KPI VS OKR&quot;&gt;&lt;/a&gt;KPI VS OKR&lt;/h3&gt;&lt;h2 id=&quot;分享中提高&quot;&gt;&lt;a href=&quot;#分享中提高&quot; class=&quot;headerlink&quot; title=&quot;分享中提高&quot;&gt;&lt;/a&gt;分享中提高&lt;/h2&gt;&lt;p&gt;有一个著名的理论，叫木桶理论。意思是木桶能装多少水，是由木桶最短的那个板来决定的。团队也是如此。团队的力量有多大，很多时候也是由能力最差的那个成员来决定的。为了提高团队整体的实力，我们必须提高每个人的能力。我们的改善必须得是可度量的，所以我们也要数字化能力的标准。&lt;/p&gt;
&lt;h2 id=&quot;提高工作效率&quot;&gt;&lt;a href=&quot;#提高工作效率&quot; class=&quot;headerlink&quot; title=&quot;提高工作效率&quot;&gt;&lt;/a&gt;提高工作效率&lt;/h2&gt;&lt;p&gt;其实很多团队都在进行着这个工作。最常见的就是会做一些小工具，来节省我们的时间。比如代码自动生成工具，自动打包工具，自动的比较工具等等。我们应该制作尽可能多的自动化工具，来解放我们的时间。&lt;/p&gt;
&lt;p&gt;为了让大家投入更多的热情来制作各种工具，团队可以制定一定的奖励规则，对制作工具的人给予奖励。&lt;/p&gt;
&lt;p&gt;公司要把最好的人才放到工具开发那一块，因为工具做好了，可以达到事半功倍的效果，所有人的效率都可以得到提高，而不仅仅是工程师。&lt;/p&gt;
&lt;h2 id=&quot;互相备份&quot;&gt;&lt;a href=&quot;#互相备份&quot; class=&quot;headerlink&quot; title=&quot;互相备份&quot;&gt;&lt;/a&gt;互相备份&lt;/h2&gt;&lt;h2 id=&quot;互相支撑&quot;&gt;&lt;a href=&quot;#互相支撑&quot; class=&quot;headerlink&quot; title=&quot;互相支撑&quot;&gt;&lt;/a&gt;互相支撑&lt;/h2&gt;&lt;h2 id=&quot;向上管理&quot;&gt;&lt;a href=&quot;#向上管理&quot; class=&quot;headerlink&quot; title=&quot;向上管理&quot;&gt;&lt;/a&gt;向上管理&lt;/h2&gt;&lt;h2 id=&quot;向下管理&quot;&gt;&lt;a href=&quot;#向下管理&quot; class=&quot;headerlink&quot; title=&quot;向下管理&quot;&gt;&lt;/a&gt;向下管理&lt;/h2&gt;&lt;h3 id=&quot;了解队员的擅长与不足&quot;&gt;&lt;a href=&quot;#了解队员的擅长与不足&quot; class=&quot;headerlink&quot; title=&quot;了解队员的擅长与不足&quot;&gt;&lt;/a&gt;了解队员的擅长与不足&lt;/h3&gt;&lt;h3 id=&quot;合理的任务分配&quot;&gt;&lt;a href=&quot;#合理的任务分配&quot; class=&quot;headerlink&quot; title=&quot;合理的任务分配&quot;&gt;&lt;/a&gt;合理的任务分配&lt;/h3&gt;&lt;h3 id=&quot;适度挑战性的任务&quot;&gt;&lt;a href=&quot;#适度挑战性的任务&quot; class=&quot;headerlink&quot; title=&quot;适度挑战性的任务&quot;&gt;&lt;/a&gt;适度挑战性的任务&lt;/h3&gt;&lt;h3 id=&quot;给出完成任务需要的资源&quot;&gt;&lt;a href=&quot;#给出完成任务需要的资源&quot; class=&quot;headerlink&quot; title=&quot;给出完成任务需要的资源&quot;&gt;&lt;/a&gt;给出完成任务需要的资源&lt;/h3&gt;&lt;h3 id=&quot;激励中成长&quot;&gt;&lt;a href=&quot;#激励中成长&quot; class=&quot;headerlink&quot; title=&quot;激励中成长&quot;&gt;&lt;/a&gt;激励中成长&lt;/h3&gt;&lt;p&gt;眼前利益与发展前景&lt;/p&gt;
&lt;h3 id=&quot;给出职业发展的机会&quot;&gt;&lt;a href=&quot;#给出职业发展的机会&quot; class=&quot;headerlink&quot; title=&quot;给出职业发展的机会&quot;&gt;&lt;/a&gt;给出职业发展的机会&lt;/h3&gt;&lt;h3 id=&quot;公开与公平中考评&quot;&gt;&lt;a href=&quot;#公开与公平中考评&quot; class=&quot;headerlink&quot; title=&quot;公开与公平中考评&quot;&gt;&lt;/a&gt;公开与公平中考评&lt;/h3&gt;&lt;h3 id=&quot;保持团队稳定&quot;&gt;&lt;a href=&quot;#保持团队稳定&quot; class=&quot;headerlink&quot; title=&quot;保持团队稳定&quot;&gt;&lt;/a&gt;保持团队稳定&lt;/h3&gt;&lt;p&gt;团队成员的诉求：团队，产品，薪资，发展。&lt;/p&gt;
&lt;p&gt;团队提供集体成长的氛围环境。&lt;/p&gt;
&lt;p&gt;令人兴奋的产品，提供持续打磨的动力。&lt;/p&gt;
&lt;p&gt;合适的薪资，使个人不过多为生活所扰。&lt;/p&gt;
&lt;p&gt;良好的发展前景，对个人的职业生涯带来腾飞。&lt;/p&gt;
&lt;p&gt;“穷得只剩钱”。小公司对企业文化不慎重视，开发团队的整体风气也没要求，招人过来只求出活，对团队个人发展是零投入的态度。这样的企业要想招到人、留住人，只剩钱了，但个人发展到一定高度，往往企业再也给不出足够的钱，这时再想留住人就很难了。这就是企业只依靠薪资吸引人带来的问题，对其他人才诉求不重视，穷得只剩钱。&lt;/p&gt;
&lt;p&gt;当收入待遇和地位与自身才能不匹配时候，离开几乎是个必然的选择。&lt;/p&gt;
&lt;h2 id=&quot;适时剔除不合格&quot;&gt;&lt;a href=&quot;#适时剔除不合格&quot; class=&quot;headerlink&quot; title=&quot;适时剔除不合格&quot;&gt;&lt;/a&gt;适时剔除不合格&lt;/h2&gt;&lt;h2 id=&quot;技术梯队&quot;&gt;&lt;a href=&quot;#技术梯队&quot; class=&quot;headerlink&quot; title=&quot;技术梯队&quot;&gt;&lt;/a&gt;技术梯队&lt;/h2&gt;&lt;p&gt;不同层次的人员配比，完成不同类型的任务。注意人员的上升下降渠道。&lt;/p&gt;
&lt;h1 id=&quot;Reference&quot;&gt;&lt;a href=&quot;#Reference&quot; class=&quot;headerlink&quot; title=&quot;Reference&quot;&gt;&lt;/a&gt;Reference&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://blogread.cn/it/article/7346?f=wb&amp;amp;utm_source=top.caibaojian.com/102758&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;以Facebook为案例剖析科技公司应有的工具文化&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MjM5ODQ2MDIyMA==&amp;amp;mid=2650712266&amp;amp;idx=1&amp;amp;sn=54d909d240eb701ae48467dc798ddc7f&amp;amp;scene=2&amp;amp;srcid=0506gUskHi8qJi6joV2483uM&amp;amp;from=timeline&amp;amp;isappinstalled=0#wechat_redirect&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;动态追踪技术（中） - Dtrace、SystemTap、火焰图&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://zh.wikipedia.org/wiki/%E6%9E%81%E9%99%90%E7%BC%96%E7%A8%8B&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;极限编程&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://zh.wikipedia.org/wiki/SOLID_(%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%AE%BE%E8%AE%A1&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;SOLID (面向对象设计)&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://zh.wikipedia.org/wiki/%E4%B8%80%E6%AC%A1%E4%B8%94%E4%BB%85%E4%B8%80%E6%AC%A1&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;一次且仅一次&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://coolshell.cn/articles/4535.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;一些软件设计的原则&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</content>
    
    <summary type="html">
    
      技术人员乐于被领导；但他们不喜欢被管理，不喜欢像牛一样被驱赶或指挥。管理者强迫人们服从他们的命令，而领导者则会带领他们一起工作。管理是客观的，没有个人感情因素，它假定被管理者没有思想和感受，被告知要做什么和该如何做。领导是引领、引导，它激励人们达成目标。领导力是带有强烈个人感情色彩的，它不是你能命令的，也不是你能测量评估和测试的。
    
    </summary>
    
      <category term="Summary" scheme="http://amao12580.github.io/categories/Summary/"/>
    
    
      <category term="Management" scheme="http://amao12580.github.io/tags/Management/"/>
    
      <category term="Specification" scheme="http://amao12580.github.io/tags/Specification/"/>
    
  </entry>
  
</feed>
